# Списковое включение

В переводе книги Филда и Харрисона Функциональное программирование вводится термин абстракция списков и включение списков. Тем не менее, в литературе используются также списковое выражение, выделение списка, списочное встраивание, генератор списка, определитель списка.

В аксиоматике теории множеств Цермело-Френкеля есть аксиома выделения, которая позволяет строить множество на основе имеющегося, путём выбора элементов, соответствующих некоторому предикату. Абстракция списков является аналогией выделения для списков8 и иногда можно даже встретить термин ZF-выражение9.

Comprehension происходит от латинского слова prehendō, которое в большинстве случаев переводится словами seize — схватить, grasp — обхватить, detain — перехватить, take by surprise — ухватить, take root — прихватить. В контексте программирования и в связке с list, comprehension несёт смысл охватывания выражением описания всех элементов списка.

Включения — это синтаксические конструкции, которые определяют структуры данных или выражения. В качестве выражений их можно использовать:
- в правой части присвоений
- в качестве аргументов для вызова функций
- в теле лямбда-функции
- как отдельный оператор. (Например: [print(x) для x в диапазоне (10)])


## Способы формирования списков
В Python имеется 3 способа генерировать списки:
- при помощи циклов;
- при помощи функции map();
- при помощи list comprehension.


```py
# Списковое включение создает новый list, применяя выражение к каждому элементу итерируемого списока:
[ <expression> for <element> in <iterable> ]

```
Также есть необязательное условие if:
```py

[ <expression> for <element> in <iterable> if <condition> ]

# Каждый <element> в <iterable> подключается к <expression> если <условие> имеет значение true. Возвращается новый список. 

```
Списковые включения можно использовать для создания списков из других списков, применяя функции к каждому элементу в списке. 


## Использование цикла For
Последовательность действий такова:
- Создаем пустой список.
- Обходим список, в котором требуется произвести ряд преобразований, или осуществляем требуемое количество итераций цикла при помощи функции range().
- Добавляем в пустой список новые значения / элементы с помощью метода append().

```py

# списковое включение, выдаёт [2, 3, 4]
[x + 1 for x in (1, 2, 3)]

# Создать список квадратов целых чисел:
squares = [x * x for x in (1, 2, 3, 4)]
print(squares)

```
Выражение for  устанавливает x для каждого значения из (1, 2, 3, 4). Результат выражения x * x добавляется во внутренний список. Внутренний список присваивается новому списку squares после завершения.

Помимо ускорения, списковые включения эквивалентны следующему циклу for:
```py

squares = []
for x in (1, 2, 3, 4):
    squares.append(x * x)

# Генерация списка заглавных букв из «Hello World»
# Так как строка является итерируемым объектом, то по ней можно пройтись в цикле.
word = 'Hello World'  # Начальное слово
s = []  # Создаем пустой список
for i in word.upper():  # Проходимся по каждой букве в строке
    s.append(i)  # Приводим все буквы к верхнему регистру

# Получить список заглавных символов из строки
[s.upper() for s in "Hello World"]


# Убрать все запятые с конца строки в списке
[w.strip(',') for w in ['these,', 'words,,', 'mostly', 'have,commas,']]

# Организовать буквы в словах в алфавитном порядке
sentence = "Beautiful is better than ugly"
["".join(sorted(word, key = lambda x: x.lower())) for word in sentence.split()]

```
    
## Генераторные выражения

Генераторное выражение очень похоже на списки. Основное отличие состоит в том, что оно не создаёт полный набор результатов сразу.
Генераторное выражение создаёт объект генератора, который затем может быть повторён.

```py

# Создание списка чисел от 0 до 49
numRange = range(0,50)

# Генерация списка кубов для чисел от 0 до 9 с использованием функции range()

s = []  # Создаем пустой список
for i in range(10):  # Осуществляем 10 итераций - от 0 до 9
    s.append(i ** 3)  # Добавляем к списку куб каждого числа
print(s)  # [0, 1, 8, 27, 64, 125, 216, 343, 512, 729]

# В Python 3, range просто возвращает генератор.
[x**3 for x in range(10)] 

```

Генераторные выражения вычисляются лениво, что означает, что они генерируют и возвращают каждое значение только тогда, когда генератор повторяется. 
Это может пригодиться при переборе больших наборов данных, без создания дубликатов набора данных в памяти:
```py

for square in (x**2 for x in range(1000000)):
    #сделает что-нибудь

```
 
## Условные выражения

В Python существует возможность использования условных выражений, поэтому вместо написания if .. else с присваиванием переменной в каждой ветке вы можете делать следующее:
```py
# делаем число всегда нечетным 
number = count if count % 2 else count - 1

# вызываем функцию, если объект не None 
name = user.name() if user is not None else 'Guest'
print "Hello", name
``` 
Приведенный выше код очень легко читается, по сравнению с оператором ternary, который выглядит следующим образом , a ? b : c , и используется в других языках. 


## Условные списки

Можно добавить один или несколько условий if для фильтрации значений.
```py

[<expression> for <element> in <iterable> if <condition>]

 Для каждого <element> в <iterable> если <condition> имеет значение True , добавить <expression> (обычно функция <element> ) в возвращаемом списке.

```

## Добавим фильтрацию или условный оператор:

```py

[x for x in (1, 2, 3) if x % 2 == 0]

numbers = [1, 2, 3, 4, 5, 6, 7]

# квадраты всех нечетных чисел
squares = [num * num for num in numbers if num % 2]

# умножаем четные числа на 2 и нечетные на 3
mul = [num * 3 if num % 2 else num * 2 for num in numbers]

```

Извлечение только четных чисел из последовательности целых чисел:
```py

[x for x in range(10) if x % 2 == 0] #Out: [0, 2, 4, 6, 8]

# Приведенный код эквивалентен:

even_numbers = [] 
for x in range(10):
    if x % 2 == 0:
        even_numbers.append(x)

print(even_numbers) #Out: [0, 2, 4, 6, 8]

```

## Условие Else

else можно использовать в списковых включениях, но нужно следить за синтаксисом. Условие if или else следует использовать перед циклом for, а не после:
```py
# создать список символов из apple, replacing согласные на '*'

# Ex - 'apple' --> ['a', '*', '*', '*' ,'e']
[x for x in 'apple' if x in 'aeiou' else '*'] # Out: SyntaxError: invalid syntax

# При использовании if / else используйте их перед циклом
[x if x in 'aeiou' else '*' for x in 'apple'] # Out:['a', '*', '*', '*', 'e']

[x + 1 if x % 2 == 0 else x for x in (1, 2, 3)]

# списковое включение с фильтрацией
[x + 1 if x % 2 == 0 else x for x in range(-3,4) if x > 0]

``` 
здесь используется другая языковая конструкция, условное выражение, которое само по себе не является частью синтаксиса включения. Учитывая, что if после  for…in является частью спискового включения и используется для фильтрации элементов из исходного кода.


## Условие в конце включения

новый_список = [«операция» for «элемент списка» in «список» if «условие»]

Такой вариант использования условий позволяет отсечь часть элементов итератора. Новый список будет короче первоначального. 
```py

# Получение списка из чисел, которые делятся на 11 без остатка
numbers = [121, 544, 111, 99, 77]  # Исходный список чисел
number11 = [num for num in numbers if num % 11 == 0]  # Выбираем только те числа, которые делятся на 11
print(number11)  # [121, 99, 77]

```
В результате мы получаем только те элементы, которые делятся на 11 без остатка. Следует обратить внимание, что условие может быть только одно (т. е. здесь невозможно использовать elif, else или другие if, как мы могли бы сделать в циклах).

## Условие в начале включения
Если требуется не фильтрация данных по какому-то критерию, а изменение типа операции над элементами последовательности, условия могут использоваться в начале генератора списков.

Общий вид конструкции:

новый_список = [«операция» if «условие» for «элемент списка» in «список»]

В отличие от предыдущего типа условий, здесь оно может дополняться вариантом else (но elif и тут невозможен).

```py

# Генерирование списка, в котором будут отмечены английские и неанглийские буквы

# нам дают строку, в которой могут присутствовать буквы любых алфавитов. 
# составить новый список, где напротив каждой буквы будет отмечено, является ли она английской или нет.

# Из модуля string импортирован объект ascii_letters, в котором содержатся только буквы английского алфавита:

ascii_letters = {str} 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

from string import ascii_letters

letters = 'hыtφтrцзqπ'  # набор букв из разных алфавитов

# Разграничиваем буквы на английские и не английские
is_eng = [f'{letter}-ДА' if letter in ascii_letters else f'{letter}-НЕТ' for letter in letters]
print(is_eng)
# ['h-ДА', 'ы-НЕТ', 't-ДА', 'φ-НЕТ', 'т-НЕТ', 'r-ДА', 'ц-НЕТ', 'з-НЕТ', 'q-ДА', 'π-НЕТ']

```

Применение условного списка вида [e for x in y if c], где e и c являются выражениями, эквивалентно list(filter(lambda x: c, map(lambda x: e, y)))

Это совершенно отличается от ... if ... else ... условного выражения (Тернарный оператор).
```py

[x if x % 2 == 0 else None for x in range(10)] # Out: [0, None, 2, None, 4, None, 6, None, 8, None]
# Здесь условное выражение - не фильтр, а оператор, определяющий значение, которое будет использоваться для элементов списка:
# <value-if-condition-is-true> if <condition> else <value-if-condition-is-false>
 
# Это становится более очевидным, если вы объедините его с другими операторами:

[2 * (x if x % 2 == 0 else -1) + 1 for x in range(10)] #Out: [1, -1, 5, -1, 9, -1, 13, -1, 17, -1]

# Приведенный выше код эквивалентен:

numbers = []
for x in range(10):
    if x % 2 == 0:
        temp = x
    else:
        temp = -1
    numbers.append(2 * temp + 1)
print(numbers)

```

Можно комбинировать тернарный оператор и if условия. Тернарный оператор работает с отфильтрованным результатом:
```py

[x if x > 2 else '*' for x in range(10) if x % 2 == 0] # Out: ['*', '*', 4, 6, 8] 
# То же самое не могло быть достигнуто только одним троичным оператором:

[x if (x > 2 and x % 2 == 0) else '*' for x in range(10)]
# Out:['*', '*', '*', '*', 4, '*', 6, '*', 8, '*']

```

## Вложенные итерации

Списки могут использовать любое количество вложенных циклов for. Каждый цикл for может иметь дополнительный связанный if. При этом порядок следования for такой же, как при написании серии вложенных for. 
```py

# Общая структура списочных представлений:

[ expression for target1 in iterable1 [if condition1]
             for target2 in iterable2 [if condition2]...
             for targetN in iterableN [if conditionN] ]

```

## Итерация двух или более списков одновременно

```py

# Вложенные циклы, дает [11, 21, 12, 22]
[x + y for x in [1, 2] for y in [10, 20]] 

# Списковые включения могут использовать вложенные итерации по переменным:

[(x, y) for x in range(1, 10) for y in range(1, 10) if x % y == 0]

[x + y for x in [1, 2, 3] if x > 2 for y in [3, 4, 5]]

[x + y for x in [1, 2, 3] for y in [3, 4, 5] if x > 2] 

data = [[1, 2], [3, 4], [5, 6]]
output = []

for each_list in data:
    for element in each_list:
        output.append(element)
print(output) # Out: [1, 2, 3, 4, 5, 6]

# эквивалентно:

data = [[1, 2], [3, 4], [5, 6]]
output = [element for each_list in data for element in each_list]
print(output) # Out: [1, 2, 3, 4, 5, 6]
```


## Приведение многомерного объекта к одномерному
```py

# Представим список из слов, который мы хотим привести к сплошному списку из букв. 
# Реализация представлена ниже.

words = ['Я', 'изучаю', 'Python']  # Список слов
letters = [letter for word in words for letter in word]  # Двойная итерация: по словам и по буквам
print(letters)  # ['Я', 'и', 'з', 'у', 'ч', 'а', 'ю', 'P', 'y', 't', 'h', 'o', 'n']

# Генерация таблицы умножения от 1 до 5

# Списковые включения могут генерировать список списков. 
# Попробуем сформировать таблицу умножения чисел от 1 до 5. 

table = [[x * y for x in range(1, 6)] for y in range(1, 6)]
print(table)

```
## Двойная итерация
Порядок двойной итерации [... for x in ... for y in ...] является контр-логичным. 
Эмпирическое правило - это следовать циклу for:
```py

def foo(i):
    return i, i + 0.5
 
# Результат:

[str(x)
    for i in range(3)
        for x in foo(i)
]

 
# можно сжать в одну строку:
[str(x) for i in range(3) for x in foo(i)]

data = [[1,2],[3,4],[5,6]]
def f():
     output=[]
     for each_list in data:
         for element in each_list:
             output.append(element)
     return output
timeit f()


# Встроенный if:

data = [[1], [2, 3], [4, 5]]
output = [element for each_list in data
                if len(each_list) == 2
                for element in each_list
                if element != 5]
print(output) # Out: [2, 3, 4] 
```

## Включение вложенного списка

Включение вложенного списка, в отличие от включения списка с вложенными циклами, являются включение списка в пределах включения списка. 

Начальным выражением может быть любое произвольное выражение, включая другое включение.
```py

#Списковое включение с вложенным циклом
[x + y for x in [1, 2, 3] for y in [3, 4, 5]] # Out: [4, 5, 6, 5, 6, 7, 6, 7, 8]

#Вложенное списковое включение
[[x + y for x in [1, 2, 3]] for y in [3, 4, 5]] #Out: [[4, 5, 6], [5, 6, 7], [6, 7, 8]]

 
# пример эквивалентен

l = []
for y in [3, 4, 5]:
    temp = []
    for x in [1, 2, 3]:
        temp.append(x + y)
    l.append(temp)

# пример транспонирования матрицы.

matrix = [[1,2,3],
          [4,5,6],
          [7,8,9]] 

[[row[i] for row in matrix] for i in range(len(matrix))]
# Out: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]


[[[i + j + k for k in 'cd'] for j in 'ab'] for i in '12']
# Out: [[['1ac', '1ad'], ['1bc', '1bd']], [['2ac', '2ad'], ['2bc', '2bd']]] 


```

## упрощённые конструкции обработки списков
```py

all_pairs = [(i, j) for i in range(5) for j in range(5) if i <= j]
# [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 1), (1, 2), (1, 3), (1, 4), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (4, 4)]

# Того же самого можно добиться такой конструкцией:


all_pairs = []
for i in range(5):
    for j in range(5):
        if i <= j:
            all_pairs.append((i, j))


```

## Изменение типов в списке

Количественные данные часто считываются в виде строк, которые должны быть преобразованы в числовые типы перед обработкой. Типы всех элементов списка могут быть преобразованы с помощью функции списковых включений или функции map().
```py

# Преобразовать список строк в целые числа.
items = ["1","2","3","4"]
[int(item) for item in items] # Out: [1, 2, 3, 4]

# Конвертируем список строк в числа с плавающей точкой.
items = ['1','2','3','4']
list(map(float, items)) # Out:[1.0, 2.0, 3.0, 4.0] 

```

## Списковые включения с участием кортежей

Для for можно указать больше одной переменной:

```py

[x + y for x, y in [(1, 2), (3, 4), (5, 6)]] # Out: [3, 7, 11]

[x + y for x, y in zip([1, 3, 5], [2, 4, 6])] # Out: [3, 7, 11]

 
# Аналог для for:

for x, y in [(1,2), (3,4), (5,6)]:
    print(x+y)

```
Если выражение, начинающее списковое включение, является кортежем, его необходимо заключить в скобки:
```py

[x, y for x, y in [(1, 2), (3, 4), (5, 6)]] # Out: SyntaxError: invalid syntax

[(x, y) for x, y in [(1, 2), (3, 4), (5, 6)]] # Out: [(1, 2), (3, 4), (5, 6)]

```

# Набор включений

Набор включений аналогичен списку включений и словарю включений, но создаёт набор, представляющий собой неупорядоченную коллекцию уникальных элементов.
```py

# комплект выражений, выдаёт {1, 2, 3}
{x for x in (1, 2, 2, 3)} 

# Набор, содержащий каждое значение в диапазоне (5):
{x for x in range(5)} # Out: {0, 1, 2, 3, 4}

# Набор чётных чисел от 1 до 10:
{x for x in range(1, 11) if x % 2 == 0} # Out: {2, 4, 6, 8, 10}

# Уникальные буквенные символы в текстовой строке:
text = "When in the Course of human events it becomes necessary for one people..."
{ch.lower() for ch in text if ch.isalpha()}

```
функция set() может использоваться с выражением генератора для получения того же результата:
```py

set(x for x in range(5)) # Out: {0, 1, 2, 3, 4}

```


## Словарное включение

Одно из применений генераторов заключается в создании словаря. 

Словарь включений аналогичен списковым включениям, за исключением того, что он создаёт объект словаря вместо списка.
```py

{x: x * x for x in (1, 2, 3, 4)} # Out: {1: 1, 2: 4, 3: 9, 4: 16}
 
это просто еще один способ написания:

dict((x, x * x) for x in (1, 2, 3, 4)) # Out: {1: 1, 2: 4, 3: 9, 4: 16} 

# словарь включений, выдаёт {'a': 1, 'b': 2}
{k: v for k, v in [('a', 1), ('b', 2)]} 

```

```py

teachers = {
    'Andy': 'English',
    'Joan': 'Maths',
    'Alice': 'Computer Science',
}
# используем  списковое включение
subjects = dict((subject, teacher) for teacher, subject in teachers.items())

# используем словарное включение 
subjects = {subject: teacher for teacher, subject in teachers.items()}

```

Как и в случае со списком, мы можем использовать условный оператор внутри словаря включения, чтобы получить только элементы словаря, удовлетворяющие заданному критерию.
```py

{name: len(name) for name in ('Stack', 'Overflow', 'Exchange') if len(name) > 6}  

# Out: {'Exchange': 8, 'Overflow': 8} 

Или переписать с помощью генераторного выражения.

dict((name, len(name)) for name in ('Stack', 'Overflow', 'Exchange') if len(name) > 6)
# Out: {'Exchange': 8, 'Overflow': 8} 

Начиная со словаря и используя словарь в качестве фильтра пары ключ-значение

initial_dict = {'x': 1, 'y': 2}
{key: value for key, value in initial_dict.items() if key == 'x'}

# Out: {'x': 1}

```
## Переключение ключа и значения словаря (инвертировать словарь)
```py

my_dict = {1: 'a', 2: 'b', 3: 'c'}
# если вы хотели поменять местами ключи и значения, вы можете использовать несколько подходов в зависимости от вашего стиля кодирования:

swapped = {v: k for k, v in my_dict.items()}
swapped = dict((v, k) for k, v in my_dict.items())
swapped = dict(zip(my_dict.values(), my_dict))
swapped = dict(zip(my_dict.values(), my_dict.keys()))
swapped = dict(map(reversed, my_dict.items()))

print(swapped)

# Out: {a: 1, b: 2, c: 3}

```

## Объединение словарей

Объедините словари и при необходимости переопределите старые значения с помощью вложенного словаря включений.
```py

dict1 = {'w': 1, 'x': 1}
dict2 = {'x': 2, 'y': 2, 'z': 2}

{k: v for d in [dict1, dict2] for k, v in d.items()}
# Out: {'w': 1, 'x': 2, 'y': 2, 'z': 2}

```

## Пробелы в списках
Более сложные списки могут быть очень длинными или становиться менее читабельными. можно разбить списковые включения на несколько строк следующим образом:
```py
[
    x for x
    in 'foo'
    if x not in 'bar'
]


``` 
