# Кортежи (tuple)

Список – это изменяемый тип данных. Т.е. если у нас есть список a = [1, 2, 3] и мы хотим заменить второй элемент с 2 на 15, то мы может это сделать, напрямую обратившись к элементу списка.

Кортеж (tuple) – это неизменяемая структура данных, которая похожа на список. 

Существует несколько причин, по которым стоит использовать кортежи вместо списков. Одна из них – это обезопасить данные от случайного изменения. Если мы получили откуда-то массив данных, и у нас есть желание поработать с ним, но при этом непосредственно менять данные мы не собираемся, тогда, это как раз тот случай, когда кортежи придутся как нельзя кстати. 

Кортежи в памяти занимают меньший объем по сравнению со списками.
```py

lst = [10, 20, 30]
tpl = (10, 20, 30)
print(lst.__sizeof__()) # 32
print(tpl.__sizeof__()) # 24

```
прирост производительности связан с тем, что кортежи работают быстрее, чем списки (т.е. на операции перебора элементов и т.п. будет тратиться меньше времени). 


## Создание кортежей
Синтаксически, кортеж - это список значений через запятую:
```py
t = 'a', 'b', 'c', 'd', 'e'
```
Хотя это и необязательно, обычно заключать кортежи в скобки:
```py
   t = ('a', 'b', 'c', 'd', 'e')
```
Создайте пустой кортеж с круглыми скобками:
```py
    t0 = ()
    type(t0)            # <type 'tuple'>

```
### Одноэлементные кортежи:
Чтобы создать кортеж с одним элементом, необходимо добавить заключительную запятую:
```py
    t1 = 'a',
    type(t1)              # <type 'tuple'>

```
Для создания одноэлементного кортежа необходимо использовать завершающую запятую.

Для одноэлементных кортежей рекомендуется использовать круглые скобки.
```py

    t2 = ('a',)           # PEP8-compliant
    t2 = 'a',             # this notation is not recommended by PEP8
    t2 = ('a', )          # this notation is not recommended by PEP8

```
    
Обратите внимание, что одно значение в скобках не является кортежем:
```py

    t2 = ('a')
    type(t2)              # <type 'str'>


```

Другой способ создать кортеж является встроенной функцией tuple .
```py

    t = tuple('lupins')
    print(t)              # ('l', 'u', 'p', 'i', 'n', 's')
    t = tuple(range(3))
    print(t)              # (0, 1, 2)


```
Для создания пустого кортежа:
```py

b = tuple()
print(type(b)) # <class 'tuple'>

```

Кортеж с заданным содержанием создается также как список, только вместо квадратных скобок используются круглые.
```py

a = (1, 2, 3, 4, 5)
print(type(a)) # <class 'tuple'>

print(a) # (1, 2, 3, 4, 5)

```

- Кортежи являются последовательностями. 
- При создании кортежи заключаются в круглые скобки. 
- Кортежи не позволяют изменять свои значения и не имеют методов.

## Доступ к элементам кортежа
Доступ к элементам кортежа осуществляется также как к элементам списка – через указание индекса. 

### Индексирование кортежей
```py

    x = (1, 2, 3)
    x[0]  # 1
    x[1]  # 2
    x[2]  # 3
    x[3]  # IndexError: tuple index out of range

```

Индексирование с отрицательными числами начнется с последнего элемента как -1:
```py

    x[-1] # 3
    x[-2] # 2
    x[-3] # 1
    x[-4] # IndexError: tuple index out of range


```
## Из кортежа можно извлекать элементы:
```py

a[3] 

```

## Срезы
Чтобы получить доступ к фрагменту [a: b], мы должны перебрать каждый элемент между индексами a и b. 

```py
## Из кортежа можно брать срезы:
a[1:3] 

```

## Индексирование ряда элементов
```py

    print(x[:-1])   # (1, 2)
    print(x[-1:])   # (3,)
    print(x[1:3])   # (2, 3) 

```

## Кортежи неизменны

Одним из основных отличий между list s и tuple с в Python является то, что кортежи являются неизменяемыми:

С кортежем мы не можем производить такие операции, т.к. элементы его изменять нельзя.
```py

b = (1, 2, 3)
print(b)

b[1] = 15
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    b[1] = 15
TypeError: 'tuple' object does not support item assignment


```
   
Точно так же, кортежи не имеют .append и .extend методы. 

Вы можете использовать += оператор, но он изменяет связывание переменной, создавая новый кортеж с новыми элементоми, а не сам кортеж:
```py

  t = (1, 2)
  q = t
  t += (3, 4)
  t # (1, 2, 3, 4)
  q # (1, 2)

```

Будьте осторожны при размещении изменяемых объектов, таких как lists, внутри кортежей. Это может привести к очень запутанным результатам при их изменении:
```py
t = (1, 2, 3, [1, 2, 3]) # (1, 2, 3, [1, 2, 3])
t[3] += [4, 5]
 
TypeError: 'tuple' object does not support item assignment


a = (1, 2, 3, 4, 5)
print(a[0])

print(a[1:3])

a[1] = 3
Traceback (most recent call last):
  File "<pyshell#24>", line 1, in <module>
    a[1] = 3
TypeError: 'tuple' object does not support item assignment

```

## Удаление кортежей
Удалить отдельные элементы из кортежа невозможно.
```py

a = (1, 2, 3, 4, 5)
del a[0]
Traceback (most recent call last):
  File "<pyshell#26>", line 1, in <module>
    del a[0]
TypeError: 'tuple' object doesnt support item deletion

```

## Но можно удалить кортеж целиком.
```py

del a
print(a)
Traceback (most recent call last):
  File "<pyshell#28>", line 1, in <module>
    print(a)
NameError: name 'a' is not defined

```

### Преобразование кортежа в список и обратно

На базе кортежа можно создать список, верно и обратное утверждение. 

Для превращения списка в кортеж достаточно передать его в качестве аргумента функции tuple().
```py

lst = [1, 2, 3, 4, 5]
print(type(lst)) # <class 'list'>
print(lst) # [1, 2, 3, 4, 5]
tpl = tuple(lst) 
print(type(tpl)) # <class 'tuple'>
print(tpl) # (1, 2, 3, 4, 5)

```

### Обратная операция также является корректной.
```py

tpl = (2, 4, 6, 8, 10)
print(type(tpl)) # <class 'tuple'>
print(tpl) # (2, 4, 6, 8, 10)
lst = list(tpl)
print(type(lst)) # <class 'list'>
print(lst) # [2, 4, 6, 8, 10]


```
## Упаковка и распаковка кортежей

Присваивания a = 1, 2, 3 также называют упаковкой.

Для распаковки значений из кортежа и выполнения нескольких назначений используйте
```py

    # unpacking AKA multiple assignment
    x, y, z = (1, 2, 3) 
    # x == 1
    # y == 2
    # z == 3

```
     
Символ _ может быть использован в качестве одноразового использования имени переменной:
```py

    a = 1, 2, 3, 4
    _, x, y, _ = a
    # x == 2
    # y == 3


```
### Реверсивные элементы
```py

    colors = "red", "green", "blue"
    rev = colors[::-1]
    # rev: ("blue", "green", "red")
    colors = rev
    # colors: ("blue", "green", "red")

```

Реверсия дает итерацию, которая преобразуется в кортеж:
```py

    rev = tuple(reversed(colors))
    # rev: ("blue", "green", "red")
    colors = rev
    # colors: ("blue", "green", "red") 

```

## Присваивание последовательностей
В Python последовательности можно присвоить последовательность значений. Присваивание происходит в соответствии с позициями элементов в последовательностях.

### Присваивание кортежей.
```py
a,b='c','d' 
a,b # ('c', 'd')

```
### Присваивание строки кортежу
```py

a,b,c='ijk' 
a,b,c # ('i', 'j', 'k')

```
### Присваивание кортежа списку
```py

[A,B]=(1,2)
A,B # (1, 2)

```
### Присваивание последовательности целых чисел переменным a,b,c
```py

a,b,c=range(3)
a,b,c # (0, 1, 2)

# Это равносильно командам a='c'; b='d'.
```
### Обмен значений переменных с помощью кортежей
```py

a,b=1,2
a,b # (1, 2)
a,b=b,a
a,b # (2, 1)

```

### Можно осуществлять присваивание одного объекта нескольким переменным
```py

a=b=c=1
a # [1]
b # 1
c # 1

```
Такое присваивание удобно выполнять для неизменяемых объектов. Следует учитывать, что если присваивается изменяемый объект, то при его изменении с помощью одной переменной, изменяются и другие переменные.
```py

a=b=c=[]
a.append(1)
a # [1]
b # [1]
c # [1]

```

## Встроенные функции кортежей

Кортежи поддерживают следующие встроенные функции

### Сравнение
Два картежа сравниваются лексикографически: считаются равными, если имеют одинаковую длину и равны их соответствующие элементы:
```py

    a = (3, 2, 1)
    b = (1, 2, 3)
    d = (3, 2, 2)
    e = (3, 2)
    f = (3, 2, 'a')
    a > b  # True
    a > d  # False
    d > b  # True
    a > e  # True
    # Python 3
    a > f  # TypeError: '>' not supported between instances of 'int' and 'str'
    # Python 2
    a > f  # False

```
Пустой кортеж — это глобально уникальный объект. Таким образом, все пустые кортежи — это один и тот же объект, а значит и адрес в памяти у таких кортежей один.
```py

  a = ()
  b = ()
  a is b # True
  id(a) == id(b)  # True

```

- Если элементы одного типа, python выполняет сравнение и возвращает результат. 
- Если элементы разных типов, он проверяет, являются ли они числами.
- Если числа, проведите сравнение.
- Если один из элементов является числом, то возвращается другой элемент.
- В противном случае типы сортируются по алфавиту. 
- Если мы достигли конца одного из списков, более длинный список будет «больше». 
- Если оба списка одинаковы, возвращается 0.
```py

    tuple1 = ('a', 'b', 'c', 'd', 'e')
    tuple2 = ('1','2','3')
    tuple3 = ('a', 'b', 'c', 'd', 'e')

    cmp(tuple1, tuple2)
    Out: 1

    cmp(tuple2, tuple1)
    Out: -1

    cmp(tuple1, tuple3)
    Out: 0

```

### Длина кортежа

Функция len возвращает общую длину кортежа
```py

    len(tuple1)

```
### Функция max
Функция max возвращает элемент из кортежа с максимальным значением
```py

    max(tuple1)
    Out: 'e'

    max(tuple2)
    Out: '3'

```

### Функция min

Функция min возвращает элемент из кортежа со значением min
```py

    min(tuple1)
    Out: 'a'

    min(tuple2)
    Out: '1'

```

## Преобразовать список в кортеж     
Мы можем менять или конвертировать объект из одного типа данных в другой. В нашем случае, мы конвертируем список в кортеж.


```py
# данный код конвертирует кортеж в список при помощи функции list.
a = [1, 2, 3]
print(a)

a[1] = 15
print(a)

```

### Встроенная функция tuple преобразует список в кортеж.
```py
    list = [1,2,3,4,5]
    tuple(list)
    Out: (1, 2, 3, 4, 5)

```

## Конкатенация кортежей

Используйте + для конкатенации двух кортежей
```py
    tuple1 + tuple2
    Out: ('a', 'b', 'c', 'd', 'e', '1', '2', '3') 

```

При удалении кортежа (например, с помощью del, или сборщика мусора) небольшой длины (не более 19 элементов), он не удалется сразу, а перемещается в очередь удаления. Эта очередь имеет 20 групп, в каждую из которых помещаются удалённые кортежи соответствующей длины, причём в первой группе хранится пустой кортеж.
```py

    tuple_0 = (1, 2, 3)
    print('tuple_0 %s' % id(tuple_0))  # 140332152236648

    tuple_1 = (1, 2, 3)
    print('tuple_1 %s' % id(tuple_1))  # 140332152236720

    del tuple_1
    # Далее предполагается, что сборка мусора уже прошла.
    # Проще всего наблюдать за работой из интерактивного сеанса
    # интерпретатора.

    tuple_2 = (1, 2, 4)
    print('tuple_2 %s' % id(tuple_2))  # 140332152236720

```

# Словарь (ассоциативный массив, dict)

Словари (dict) – это одна из наиболее часто используемых структур данных, позволяющая хранить объекты, для доступа к которым используется ключ. 

Словарь (dict) представляет собой структуру данных (которая ещё называется ассоциативный массив), предназначенную для хранения произвольных объектов с доступом по ключу. Данные в словаре хранятся в формате ключ – значение. Если вспомнить такую структуру как список, то доступ к его элементам осуществляется по индексу, который представляет собой целое неотрицательное число, причем мы сами, непосредственно, не участвуем в его создании (индекса). В словаре аналогом индекса является ключ, при этом ответственность за его формирование ложится на программиста.

В массиве или в списке индекс - это целое число. Традиционной является следующая ситуация:
```py

Days = ['Sunday', 'Monday', 'Tuesday', 'Wednessday', 'Thursday', 'Friday', 'Saturday']
Days[0]
'Sunday'
Days[1]
'Monday'

```
### обратное соответствие
```py

Days['Sunday']
0
Days['Monday']
1

```
При помощи списка или массива это сделать невозможно, нужно использовать ассоциативный массив или словарь.

В словаре индекс может быть любого неизменяемого типа! 
Индексы, как и сами хранимые значения, задаются явно:
```py

Days = {
    'Sunday': 0,
    'Monday': 1,
    'Tuesday': 2,
    'Wednessday': 3,
    'Thursday': 4,
    'Friday': 5,
    'Saturday': 6
}
Days['Sunday']
0
Days['Monday']
1
Days['Yesterday']
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
KeyError: 'Yesterday'

```
При попытке обратиться к несуществующему элементу ассоциативного массива мы получаем исключение KeyError.

Особенностью ассоциативного массива является его динамичность: в него можно добавлять новые элементы с произвольными ключами и удалять уже существующие элементы.
```py

Days['Yesterday'] = -1
print(Days['Yesterday'])
-1

```
При этом размер используемой памяти пропорционален размеру ассоциативного массива. Доступ к элементам ассоциативного массива выполняется хоть и медленнее, чем к обычным массивам, но в целом довольно быстро.

Значения ключей уникальны, двух одинаковых ключей в словаре быть не может. А вот значения могут быть одинаковыми.
```py

Days['Tomorrow'] = -1
Days['Yesterday'] == Days['Tomorrow']
True

```
Ключом может быть произвольный неизменяемый тип данных: целые и действительные числа, строки, кортежи. Ключом в словаре не может быть множество, но может быть элемент типа frozenset: специальный тип данных, являющийся аналогом типа set, который нельзя изменять после создания. Значением элемента словаря может быть любой тип данных, в том числе и изменяемый.

## Создание словаря
Пустой словарь можно создать, указав пустые фигурные скобки:
```py

# creating an empty dictionary
dictionary = {}
print(type(dictionary)) # <class 'dict'>

```
Если необходимо создать словарь с заранее подготовленным набором данных
```py

# Creating and populating it with values
d1 = dict(Ivan="manager", Mark="worker")
print(d1) # {'Mark': 'worker', 'Ivan': 'manager'}
d2 = {"A1":"123", "A2":"456"}
print(d2) # {'A2': '456', 'A1': '123'}

# creating an empty dictionary
dictionary = {}
# And populating it after
dictionary['eggs'] = 5
dictionary['milk'] = 2

```
Правила создания словаря:
- Каждый ключ должен быть уникальным ( в противном случае он будет перезаписан)
- Каждый ключ должен быть hashable (можно использовать hash - функцию), в противном случае  будет выброшен TypeError)
```py

# Values can also be lists
mydict = {'a': [1, 2, 3], 'b': ['one', 'two', 'three']}

# Use list.append() method to add new elements to the values list
mydict['a'].append(4)   # => {'a': [1, 2, 3, 4], 'b': ['one', 'two', 'three']}
mydict['b'].append('four')  # => {'a': [1, 2, 3, 4], 'b': ['one', 'two', 'three', 'four']}

# We can also create a dictionary using a list of two-items tuples
iterable = [('eggs', 5), ('milk', 2)]
dictionary = dict(iterables)

# Or using keyword argument:
dictionary = dict(eggs=5, milk=2)

# Another way will be to use the dict.fromkeys:
dictionary = dict.fromkeys((milk, eggs))  # => {'milk': None, 'eggs': None}
dictionary = dict.fromkeys((milk, eggs), (2, 5))  # => {'milk': 2, 'eggs': 5}

```     

## Конструктор dict ()
dict() Конструктор может быть использован для создания словарей из именованных аргументов, или из одного Iterable пар ключ-значение, или из одного словаря и именованных аргументов.
```py

d = dict()                    # emtpy dict
d = dict(key='value')         # explicit keyword arguments
d = dict([('key', 'value')])  # passing in a list of key/value pairs

# make a shallow copy of another dict (only possible if keys are only strings!)
d = dict(**otherdict)         

dict(a=1, b=2, c=3)                   # {'a': 1, 'b': 2, 'c': 3}
dict([('d', 4), ('e', 5), ('f', 6)])  # {'d': 4, 'e': 5, 'f': 6}
dict([('a', 1)], b=2, c=3)            # {'a': 1, 'b': 2, 'c': 3}
dict({'a' : 1, 'b' : 2}, c=3)         # {'a': 1, 'b': 2, 'c': 3} 

```
кортежи можно использовать в качестве ключа у словаря.

## Избежание исключений KeyError

Одна из распространенных ошибок при использовании словарей - доступ к несуществующему ключу. Это обычно приводит к KeyError исключения
```py

mydict = {}
mydict['not there']
     
Traceback (последний вызов был последним): File " ", строка 1, в KeyError: «не там»

```
## Добавление и удаление элемента
Чтобы добавить элемент в словарь нужно указать новый ключ и значение.
```py

d['newkey'] = 42

# Кроме того , можно добавить list и dictionary в качестве значения:

d['new_list'] = [1, 2, 3]
d['new_dict'] = {'nested_dict': 1}


```

## Удаление ключей
Для удаления ключа и соответствующего значения из словаря можно использовать del

Чтобы удалить элемент, удалите ключ из словаря:
```py

del d['newkey']

d2 = {"A1":"123", "A2":"456"}
del d2["A1"]
print(d2)
{'A2': '456'}


# Удаляем значение с ключом "противостоять" из словаря
del dictionary['противостоять']
```

## Работа со словарем
Проверка наличия ключа в словаре производится с помощью оператора in.
```py

d2 = {"A1":"123", "A2":"456"}
"A1" in d2
True
"A3" in d2
False

```
## Доступ к элементу словаря
Для получения значения конкретного ключа используются квадратные скобки []. Предположим, что в нашем словаре есть пара 'марафон': 26.

Доступ к элементу словаря, осуществляется как же как доступ к элементу списка, только в качестве индекса указывается ключ.
```py

dictionary = {"Hello": 1234, "World": 5678}
print(dictionary["Hello"])

```
## Методы словарей
У словарей доступен следующий набор методов.

### clear()
Удаляет все элементы словаря.
```py

d2 = {"A1":"123", "A2":"456"}
print(d2)
{'A2': '456', 'A1': '123'}
d2.clear()
print(d2)
{}

```
### copy()
Создается новая копия словаря.
```py

d2 = {"A1":"123", "A2":"456"}
d3 = d2.copy()
print(d3)
{'A1': '123', 'A2': '456'}
d3["A1"]="789"
print(d2)
{'A2': '456', 'A1': '123'}
print(d3)
{'A1': '789', 'A2': '456'}

```
### fromkeys(seq[, value])
Создает новый словарь с ключами из seq и значениями из value. По умолчанию value присваивается значение None.

### get(key)
Метод get() возвращает значение по указанному ключу. Если указанного ключа не существует, метод вернёт None.
```py
d = {"A1":"123", "A2":"456"}
d.get("A1")

story_count = {'сто': 100,
               'девяносто': 90,
               'двенадцать': 12,
               'пять': 5}

# Ключ "двенадцать" существует и метод get в данном случае вернёт 12
story_count.get('двенадцать')

# Метод можно использовать для проверки наличия ключей в словаре:

story_count.get('два')
None

```
### значение по умолчанию
Один из способов избежать ошибок являются использование метода dict.get, который позволяет указать значение по умолчанию в случае отсутствующего ключа.
```py

value = mydict.get(key, default_value)

```
возвращает mydict[key], если существует, в противном случае возвращает default_value. 
это не добавляет key к mydict . Так что если вы хотите сохранить эту ключевую пару значений, вы должны использовать mydict.setdefault(key, default_value), который не хранить пару ключей значения.

```py

mydict = {}
print(mydict) # {}
print(mydict.get("foo", "bar")) # bar
print(mydict) # {}
print(mydict.setdefault("foo", "bar")) # bar
print(mydict) # {'foo': 'bar'}

```
Альтернативный способ справиться с проблемой - поймать исключение
```py

     try:
        value = mydict[key]
    except KeyError:
        value = default_value

```
Вы также можете проверить, если ключ находится в словаре.
```py

   if key in mydict:
        value = mydict[key]
   else:
        value = default_value

```
### items()
Возвращает элементы словаря (ключ, значение) в отформатированном виде.
```py

d = {"A1":"123", "A2":"456"}
d.items()
dict_items([('A2', '456'), ('A1', '123')])

```
Если вы хотите работать как с ключом и его соответствующим значением, вы можете использовать items() метод:
```py

print(mydict.items())

# dict_items([('b', '2'), ('a', '1')])

```

### keys()
Метод keys() возвращает коллекцию ключей в словаре.
```py

d = {"A1":"123", "A2":"456"}
d.keys()

```
- Метод keys возвращает представление ключей всех элементов.
- Метод values возвращает представление всех значений.
- Меод items возвращает представление всех пар (кортежей) из ключей и значений.
```py

A = dict(a='a', b='b', c='c')
k = A.keys()
v = A.values()
k, v
(dict_keys(['c', 'b', 'a']), dict_values(['c', 'b', 'a']))
A['d'] = 'a'
k, v
(dict_keys(['d', 'c', 'b', 'a']), dict_values(['a', 'c', 'b', 'a']))

```
Учтите что итерироваться по представлениям изменяя словарь нельзя
```py

for key in A.keys():
     del A[key]

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RuntimeError: dictionary changed size during iteration

```
Можно, если в начале скопировать представление в список
```py

for key in list(A.keys()):
    del A[key]

A
{}

```

## pop(key[, default])
Метод pop() удаляет ключ и возвращает соответствующее ему значение.
Если ключ key есть в словаре, то данный элемент удаляется из словаря и возвращается значение по этому ключу, иначе будет возвращено значение default. Если default не указан и запрашиваемый ключ отсутствует в словаре, то будет вызвано исключение KeyError.
```py

d = {"A1":"123", "A2":"456"}
d.pop("A1")
'123'
print(d)
{'A2': '456'}


```

### popitem()
Удаляет и возвращает пару (ключ, значение) из словаря. Если словарь пуст, то будет вызвано исключение KeyError.
```py

d = {"A1":"123", "A2":"456"}
d.popitem()
('A2', '456')
print(d)
{'A1': '123'}

```

### setdefault(key[, default])
Если ключ key есть в словаре, то возвращается значение по ключу. Если такого ключа нет, то в словарь вставляется элемент с ключом key и значением default, если default не определен, то по умолчанию присваивается None.
```py

d = {"A1":"123", "A2":"456"}
d.setdefault("A3", "777") # '777'
print(d) # {'A2': '456', 'A3': '777', 'A1': '123'}
d.setdefault("A1") # '123'
print(d) # {'A2': '456', 'A3': '777', 'A1': '123'}


d = {}
{}
d.setdefault('Another_key', []).append("This worked!")
d
{'Another_key': ['This worked!']}
```

### update([other])
Обновить словарь парами (key/value) из other, если ключи уже существуют, то обновить их значения.
```py

d = {"A1":"123", "A2":"456"}
d.update({"A1":"333", "A3":"789"})
print(d) # {'A2': '456', 'A3': '789', 'A1': '333'}

```
Метод update() пригодится, если нужно обновить несколько пар сразу. Метод принимает другой словарь в качестве аргумента.

### values()
Метод values() возвращает коллекцию значений в словаре.
```py

d = {"A1":"123", "A2":"456"}
d.values()
dict_values(['456', '123'])


```
## Словарь со значениями по умолчанию

Доступен в стандартной библиотеке как defaultdict
```py

from collections import defaultdict

d = defaultdict(int)
d['key']                         # 0
d['key'] = 5
d['key']                         # 5

d = defaultdict(lambda: 'empty')
d['key']                         # 'empty'
d['key'] = 'full'
d['key']                         # 'full'


```
## Создание упорядоченного словаря

Вы можете создать упорядоченный словарь, который будет следовать определенному порядку при переборе ключей в словаре.

Используйте OrderedDict из collections модуля. Это будет всегда возвращать элементы словаря в исходном порядке вставки при повторении.
```py

from collections import OrderedDict

d = OrderedDict()
    d['first'] = 1
    d['second'] = 2
    d['third'] = 3
    d['last'] = 4

    # Outputs "first 1", "second 2", "third 3", "last 4"
    for key in d:
        print(key, d[key]) 

```
## Слияние словарей

Рассмотрим следующие словари:
```py

fish = {'name': "Nemo", 'hands': "fins", 'special': "gills"}
dog = {'name': "Clifford", 'hands': "paws", 'color': "red"}

fishdog = {**fish, **dog}
fishdog
# {'hands': 'paws', 'color': 'red', 'name': 'Clifford', 'special': 'gills'}

from collections import ChainMap
dict(ChainMap(fish, dog))
# {'hands': 'fins', 'color': 'red', 'special': 'gills', 'name': 'Nemo'}

from itertools import chain
dict(chain(fish.items(), dog.items()))
# {'hands': 'paws', 'color': 'red', 'name': 'Clifford', 'special': 'gills'}
 

```
## Завершающая запятая

Как и списки и кортежи, вы можете добавить запятую в своем словаре.
```py

     role = {"By day": "A typical programmer",
            "By night": "Still a typical programmer", }

    # PEP 8 требует, чтобы вы оставляли пробел между конечной запятой и закрывающей скобкой.
    


```
## Все комбинации значений словаря
```py

     options = {
        "x": ["a", "b"],
        "y": [10, 20, 30]
    } 

```
Предположим , вы хотите , чтобы исследовать "x"="a" с "y"=10 , то "x"="a" с "y"=10 , и так далее , пока вы не исследовали все возможные комбинации.

Вы можете создать список, который возвращает все такие комбинации значений, используя следующий код.
```py

import itertools

options = {
        "x": ["a", "b"],
        "y": [10, 20, 30]}

keys = options.keys()
values = (options[key] for key in keys)
combinations = [dict(zip(keys, combination)) for combination in itertools.product(*values)]
print combinations 

```
Это дает нам следующий список , хранящийся в переменной combinations :
```py

     [{'x': 'a', 'y': 10},
     {'x': 'b', 'y': 10},
     {'x': 'a', 'y': 20},
     {'x': 'b', 'y': 20},
     {'x': 'a', 'y': 30},
     {'x': 'b', 'y': 30}] 
```

## Перебор словаря
```py

    d = {'a': 1, 'b': 2, 'c':3}
    for key in d:
        print(key, d[key])
    # c 3
    # b 2
    # a 1


```     

# Множество (set)
Множество в языке Python — это структура данных, эквивалентная множествам в математике. Элементы могут быть различных типов. Порядок элементов не определён.

Действия, которые можно выполнять с множеством:
- добавлять и удалять элементы,
- проверять принадлежность элемента множеству,
- перебирать его элементы,
- выполнять операции над множествами (объединение, пересечение, разность).

Операция “проверить принадлежность элемента” выполняется в множестве намного быстрее, чем в списке.

Элементами множества может быть любой неизменяемый тип данных: числа, строки, кортежи.

Изменяемые типы данных не могут быть элементами множества, в частности, нельзя сделать элементом множества список (вместо этого используйте неизменяемый кортеж) или другое множество. Требование неизменяемости элементов множества накладывается особенностями представления множества в памяти компьютера.

## Задание множеств
Множество задается перечислением в фигурных скобках. Например:
```py

A = {1, 2, 3}

```
## Исключением явлеется пустое множество:
```py

A = set()       # A -- множество
D = {}          # D -- не пустое множество, а пустой словарь!

```
Если функции set передать в качестве параметра список, строку или кортеж, то она вернет множество, составленное из элементов списка, строки, кортежа. Например:
```py

>>> A = set('qwerty')
>>> print(A)
{'e', 'q', 'r', 't', 'w', 'y'}.

```
Каждый элемент может входить в множество только один раз.
```py

>>> A = {1, 2, 3}
>>> B = {3, 2, 3, 1}
>>> print(A == B) # A и B — равные множества.
True
>>> set('Hello')
{'H', 'e', 'l', 'o'}

```
## Работа с элементами множеств

- x in A  принадлежит ли элемент x множеству A (возвращают значение типа bool)  O(1)
- x not in A  то же, что not x in A O(1)
- A.add(x)  добавить элемент x в множество A  O(1)
- A.discard(x)  удалить элемент x из множества A  O(1)
- A.remove(x) удалить элемент x из множества A  O(1)
- A.pop() удаляет из множества один случайный элемент и возвращает его  O(1)

Поведение discard и remove различается тогда, когда удаляемый элемент отсутствует в множестве: discard не делает ничего, а метод remove генерирует исключение KeyError. Метод pop также генерирует исключение KeyError, если множество пусто.

При помощи цикла for можно перебрать все элементы множества:
```py


Primes = {2, 3, 5, 7, 11}
for num im Primes:
    print(num)
```
Из множества можно сделать список при помощи функции list:
```py

>>> A = {1, 2, 3, 4, 5}
>>> B = list(A) # [1, 2, 3, 4, 5]

```
## Операции с множествами, обычные для математики
     
- A | B A.union(B)  Возвращает множество, являющееся объединением множеств A и B. O(len(A)+len(B))
- A | = B A.update(B) Записывает в A объединение множеств A и B.  O(len(A)+len(B))
- A & B A.intersection(B) Возвращает множество, являющееся пересечением множеств A и B. O(min(len(A), len(B))
- A &= B A.intersection_update(B) Записывает в A пересечение множеств A и B.  O(min(len(A), len(B))
- A - B A.difference(B) Возвращает разность множеств A и B (элементы, входящие в A, но не входящие в B).  O(len(A)+len(B))
- A -= B A.difference_update(B) Записывает в A разность множеств A и B. O(len(A)+len(B))
- A ^ B A.symmetric_difference(B) Возвращает симметрическую разность множеств A и B (элементы, входящие в A или в B, но не в оба из них одновременно).  O(len(A)+len(B))
- A ^= B A.symmetric_difference_update(B) Записывает в A симметрическую разность множеств A и B.  O(len(A)+len(B))
- A <= B A.issubset(B)  Возвращает True, если A является подмножеством B. O(len(A))
- A >= B A.issuperset(B)  Возвращает True, если B является подмножеством A. O(len(B))
- A < B Эквивалентно A <= B and A != B  O(len(A))
- A > B Эквивалентно A >= B and A != B  O(len(B))

В случае, если нужно провести процедуру, затрагивающую все элементы множества, то его трудоемкость будет O(N).


# Практическая работа по использованию словарей

## Упражнение №1. Подсчет слов
Дан текст на некотором языке. Требуется подсчитать сколько раз каждое слово входит в этот текст и вывести десять самых часто употребяемых слов в этом тексте и количество их употреблений.

В качестве примера возьмите файл с текстом лицензионного соглашения Python /usr/share/licenses/python/LICENSE.


## Упражнение №2. Перевод текста
Дан словарь task4/en-ru.txt с однозначным соответствием английских и русских слов в таком формате:
```

cat - кошка

dog - собака

mouse - мышь

house - дом

eats - ест

in - в

too - тоже

```
Здесь английское и русское слово разделены двумя табуляциями и минусом: '\t-\t'.

В файле task2/input.txt дан текст для перевода, например:
```

Mouse in house. Cat in house.
Cat eats mouse in dog house.
Dog eats mouse too.

```
Требуется сделать подстрочный перевод с помощью имеющегося словаря и вывести результат в output.txt. Незнакомые словарю слова нужно оставлять в исходном виде.

## Упражнение №3. Страны и Языки
Дан список стран и языков на которых говорят в этой стране в формате <Название Страны> : <язык1> <язык2> <язык3> ... в файле task5/input.txt. На ввод задается N - длина списка и список языков. Для каждого языка укажите, в каких странах на нем говорят.
```

Ввод  Вывод
3  
азербайджанский Азербайджан
греческий Кипр Греция
китайский Китай Сингапур
```
## Упражнение №4. Сделать русско-английский словарь
В файле task2/en-ru.txt находятся строки англо-русского словаря в таком формате:
```
cat - кошка
dog - собака
home - домашняя папка, дом
mouse - мышь, манипулятор мышь
to do - делать, изготавливать
to make - изготавливать

```
Здесь английское слово (выражение) и список русских слов (выражений) разделены двумя табуляциями и минусом: '\t-\t'.

Требуется создать русско-английский словарь и вывести его в файл ru-en.txt в таком формате:
```

делать - to do
дом - home
домашняя папка - home
изготавливать - to do, to make
кошка - cat
манипулятор мышь - mouse
мышь - mouse
собака - dog

```
Порядок строк в выходном файле должен быть словарным с человеческой точки зрения (так называемый лексикографический порядок слов). То есть выходные строки нужно отсортировать.

## Упражнение №5. Синхронизация словарей
Даны два файла словарей: task1/en-ru.txt и task1/ru-en.txt
```

en-ru.txt:

home - домашняя папка
mouse - манипулятор мышь

ru-en.txt:

дом - home
мышь - mouse

```
Требуется синхронизировать и актуализировать их содержимое.
```

en-ru.txt:

home - домашняя папка, дом
mouse - манипулятор мышь, мышь
ru-en.txt:

дом - home
домашняя папка - home
манипулятор мышь - mouse
мышь - mouse

```
## Упражнение №6
Вывести на экран все элементы множества A, которых нет в множестве B.
```py

A = set('bqlpzlkwehrlulsdhfliuywemrlkjhsdlfjhlzxcovt')
B = set('zmxcvnboaiyerjhbziuxdytvasenbriutsdvinjhgik')

```
## Упражнение №7
Даны четыре множества:
```py

A = set('0123456789')
B = set('02468')
C = set('12345')
D = set('56789')

```
Найти элементы, принадлежащие множеству E:
