# посмотрим, что возвращает функция, если не использовать ключевое слово yield:

def cube_numbers(nums):  
    cube_list = []
    for i in nums:
        cube_list.append(i**3)
    return cube_list

cubes = cube_numbers([1, 2, 3, 4, 5])

print(cubes)

# создается функция cube_numbers, которая принимает список чисел, вычисляет их куб и возвращает вызывающему объекту список целиком. При вызове этой функции список кубов возвращается и сохраняется в переменную cubes. 

# Теперь, изменим сценарий, так чтобы он возвращал генератор.

def cube_numbers(nums):  
    for i in nums:
        yield(i**3)

cubes = cube_numbers([1, 2, 3, 4, 5])

print(cubes)

# функция cube_numbers возвращает генератор вместо списка кубов чисел. 
# Создать генератор с помощью ключевого слова yield очень просто. 
# Здесь нам не нужна временная переменная cube_list для хранения куба числа. 
# Кроме того, не используется оператор return, но вместо него используется слово yield для возвращения куба числа внутри цикла.

# Несмотря на то, что был произведён вызов функции cube_numbers, она фактически не выполняется на данный момент времени, и в памяти еще нет элементов.

# Получение значение из генератора:

next(cubes) # функция возвратит "1"

# Теперь, когда снова вызывается next генератора, функция cube_numbers возобновит выполнение с того места, где она ранее остановилась на yield. Функция будет продолжать выполняться до тех пор, пока снова не найдет yield. Следующая функция будет продолжать возвращать значение куба по одному, пока все значения в списке не будут проитерированы.

# Как только все значения будут проитерированы, следующий вызов функции создаст исключение StopIteration. Важно отметить, что генератор кубов не хранит какие-либо элементы в памяти, а значения в кубе вычисляются во время выполнения, возвращаются и забываются. Используется только дополнительная память для хранения данных состояния самого генератора, которая, как правило, гораздо меньше, чем полный список. Это делает генераторы идеально подходящими для ресурсоемких задач.

# Свой вариант range:
def cool_range(start, stop, inc):
    x = start
    while x < stop:
        yield x
        x += inc

for n in cool_range(1, 5, 0.5):
    print(n)
# 1
# 1.5
# ...
# 4.5

print(list(cool_range(0, 2, 0.5)))
# [0, 0.5, 1.0, 1.5]

## Это генератор чисел Фибоначчи:
# Fibonacci numbers

class FibonacciGenerator:
    def __init__(self):
        self.prev = 0
        self.cur = 1

    def __next__(self):
        result = self.prev
        self.prev, self.cur = self.cur, self.prev + self.cur
        return result

    def __iter__(self):
        return self

for i in FibonacciGenerator():
    print(i)
    
    if i > 100:
        break


## используя ключевое слово yield можно сильно упростить реализацию:

def fibonacci():
    prev, cur = 0, 1
    while True:
        yield prev
        prev, cur = cur, prev + cur

for i in fibonacci():
    print(i)
    if i > 100:
        break

# Любая функция в Python, в теле которой встречается ключевое слово yield, называется генераторной функцией — при вызове она возвращает объект-генератор.

# Объект-генератор реализует интерфейс итератора, соответственно с этим объектом можно работать, как с любым другим итерируемым объектом.

fib = fibonacci()
print(next(fib))
print(next(fib))

for num, fib in enumerate(fibonacci()):
    print('{0}: {1}'.format(num, fib))
    if num > 9:
        break
