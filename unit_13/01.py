# Когда вы создаёте список (list) вы можете считывать его элементы по одному — это называется итерацией.
lst = [1, 2, 3]

for i in lst:
    print(i)

# lst — итерируемый объект (iterable). Когда вы используете списковые выражения (list comprehensions), вы создаёте список — итерируемый объект:

st = [x*x for x in range(3)]
for i in st:
    print(i)

# Любое объект который вы можете использовать в конструкции for … in … является итерирумым: списки, строки, файловые объекты и т.п.. Итерирумые объекты достаточно удобны потому что вы можете считывать из них столько данных, сколько вам необходимо, но при этом вы храните все значения последовательности в памяти и это не всегда приемлемо, особенно если вы имеете достаточно большие последовательности.

## Генераторы
# Генераторы — итерируемые объекты, но, в общем случае, вы можете их использовать только один раз. Генераторы не хранят все значения в памяти, а генерируют значения на лету — по мере запроса:

generator = (x*x for x in range(3))
for i in generator:
    print(i)

# Код выглядит почти так же, как и в предыдущем примере, только вместо квадратных скобок («[<…>]») были использованы круглые («(<…>)»). вы не можете выполнить цикл по generator во второй раз, поскольку ничего в памяти не хранится, попытка пройтись второй раз будет просто проигнорирована, т.к. generator выбросит при первом запросе на получение следующего значения StopIterationError, однако, вы это не заметите, если будете использовать цикл for, это исключение будет перехвачено и интерпретировано как конец цикла). 

# это можно проверить:
generator.next()
# next — это метод для получения следующего значения генератора, 
# если вы его используете не в цикле for.
# StopIteration:
# Traceback (most recent call last):
#   File "01.py", line 25, in <module>
#     generator.next()
# AttributeError: 'generator' object has no attribute 'next'

