## Yield 
# Yield — это ключевое слово которое используется так же, как и слово return. 
# Разница в том, что функция при этом начинает возвращать генератор вместо значения.

def generator():
    for i in (1, 2, 3):
        yield i

g = generator() # create a generator

print(g) # <generator object generator at 0x2e58870>
for i in g:
    print(i)

# когда вы вызываете функцию, в теле которой находится yield, выполнение этой функции не происходит. 
# Вместо выполнения, функция вернёт объект-генератор. 
# Код будет выполнятся при каждой итерации — будь то цикл «for <…> in <generator>» или вызов метода <generator>.next().

# При первом исполнении кода тела функции код будет выполнен с начала и до первого встретившегося оператора yield. 
# После этого будет возвращено первое значение и выполнение тела функции опять приостановлено. 
# Запрос следующего значения у генератора во время итерации заставит код тела функции выполняться дальше (с предыдущего yield), пока не встретится следующий yield. 
# Генератор считается закончившимся в случае если при очередном исполнении кода тела функции не было встречено ни одного оператора yield.

# Генераторы это тоже итерируемые объекты, но прочитать их можно лишь один раз. 
# Это связано с тем, что они не хранят значения в памяти, а генерируют их на лету:

mygenerator = (x*x for x in range(3))
for i in mygenerator :
    print(i)

# Всё то же самое, разве что используются круглые скобки вместо квадратных. 
# Нельзя применить конструкцию for i in mygenerator второй раз, так как генератор может быть использован только единожды: он вычисляет 0, потом забывает про него и вычисляет 1, завершаяя вычислением 4 — одно за другим.

# Напишем функцию, которая генерирует необходимое нам количество единиц.

def simple_generator(val):
   while val > 0:
       val -= 1
       yield 1

gen_iter = simple_generator(5)

print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
# print(next(gen_iter))

# Ключевым моментом для понимания работы генераторов является то, при вызове yield функция не прекращает свою работу, а “замораживается” до очередной итерации, запускаемой функцией next(). Если вы в своем генераторе, где-то используете ключевое слово return, то дойдя до этого места будет выброшено исключение StopIteration, а если после ключевого слова return поместить какую-либо информацию, то она будет добавлена к описанию StopIteration.

# Чтобы создать генератор, необходимо определить функцию, как обычно, но использовать yield вместо return, указывая интерпретатору, что эту функцию следует рассматривать как итератор:

def countdown(num):
    print('Starting')
    while num > 0:
        yield num
        num -= 1

# Оператор yield приостанавливает функцию и сохраняет локальное состояние, чтобы его можно было возобновить с того места, где оно было остановлено.

# Что происходит, когда вы вызываете эту функцию?

val = countdown(5)
print(val) # <generator object countdown at 0x10213aee8>

# Вызов функции не выполняет ее. 
# Вместо этого функция возвращает объект-генератор, 
# который используется для управления выполнением.

# Объекты генератора выполняются при вызове next():

next(val)

# При первом вызове next() выполнение начинается с начала тела функции и продолжается до следующего оператора yield, где возвращается значение справа от оператора, последующие вызовы next() продолжаются с оператора yield до конец функции, затем новый обход цикла и продолжение с начала тела функции, пока не будет вызван другой выход. Если yield не вызывается (что в нашем случае означает, что условие while не отрабатывается, потому что num <= 0), возникает исключение StopIteration:

next(val)
next(val)
next(val)
next(val)
# next(val)
# Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# StopIteration

def yrange(n):
    i = 0
    while i < n:
        yield i
        i += 1

y = yrange(3)
print(y) # <generator object yrange at 0x401f30>
print(next(y))
print(next(y))
