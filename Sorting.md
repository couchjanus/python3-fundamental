# Алгоритмы сортировки в Python

## Пузырьковая сортировка (Bubble Sort)
Этот самый простой алгоритм сортировки который выполняет итерации по списку, сравнивая элементы попарно и меняя их местами, пока более крупные элементы не перестанут всплывать до конца списка, а более мелкие элементы не будут оставаться снизу.

Алгоритм Bubble Sort заключается в циклических проходах по массиву, за каждый проход элементы массива попарно сравниваются и, если их порядок не правильный, то осуществляется обмен. Обход массива повторяется до тех пор, пока массив не будет упорядочен.

- Сначала сравниваются первые два элемента списка.
- Если первый элемент больше второго, мы меняем их местами. 
- Если они уже в нужном порядке, мы оставляем их как есть. 
- Затем мы переходим к следующей паре элементов, сравниваем их значения и меняем местами при необходимости. Этот процесс продолжается до последней пары элементов в списке.
- Достигнув конца списка, повторяем этот процесс для каждого элемента снова. 

Очевидно, что для оптимизации алгоритма нам нужно остановить его, когда он закончит сортировку.

## Реализация пузырьковой сортировки:
```py

def bubble_sort(nums):  
    # We set swapped to True so the loop looks runs at least once
    # Вначале мы установили для swapped значение True, чтобы алгоритм прошел по списку хотя бы один раз.
    swapped = True
    # Алгоритм работает в цикле while, прерываясь только тогда, когда никакие элементы не меняются местами. 
    while swapped:
        # Откуда нам знать, что мы закончили сортировку? Если бы элементы были отсортированы, то нам не пришлось бы их менять местами. Таким образом, всякий раз, когда мы меняем элементы, мы устанавливаем флаг в True, чтобы повторить процесс сортировки. Если перестановок не произошло, флаг останется False, и алгоритм остановится.

        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                # Swap the elements
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                # Set the flag to True so we'll loop again
                swapped = True

# Verify it works
random_list_of_nums = [5, 2, 1, 8, 4]  
bubble_sort(random_list_of_nums)  
print(random_list_of_nums)  



# сортировка пузырьком
def bubble_sort(array):
    length = len(array)
    for i in range(0, length):
        for j in range(0, length - i - 1):
            if array[j] > array[j + 1]:
                temp = array[j]
                array[j] = array[j + 1]
                array[j + 1] = temp

print("Сортировка пузырьком")
arr = []
n = int(input("Введите длину массива: ")) 
for i in range(0, n): 
    element = int(input("arr[" + str(i + 1) + "] = "))   
    arr.append(element)
bubble_sort(arr) 
print("Отсортированный массив: ") 
print(arr)
```

Сложность пузырьковой сортировки в худшем случае (когда список отсортирован в обратном порядке) равна O(n^2).

## Сортировка выбором (Selection Sort)
Этот алгоритм сегментирует список на две части: отсортированные и несортированные. Он постоянно удаляет наименьший элемент из несортированного сегмента списка и добавляет его в отсортированный сегмент.

### Алгоритм Selection Sort
На практике нам не нужно создавать новый список для отсортированных элементов, мы будет обрабатывать крайнюю левую часть списка как отсортированный сегмент. Затем мы ищем во всем списке наименьший элемент и меняем его на первый элемент.

Теперь мы знаем, что первый элемент списка отсортирован, мы получаем наименьший элемент из оставшихся элементов и заменяем его вторым элементом. Это повторяется до тех пор, пока последний элемент списка не станет оставшимся элементом для изучения.

### Реализация Selection Sort
```py
# Сортировка выбором (Selection Sort)

# Этот алгоритм сегментирует список на две части: отсортированные и несортированные. 
# Он постоянно удаляет наименьший элемент из несортированного сегмента списка 
# и добавляет его в отсортированный сегмент.

# Алгоритм Selection Sort
# На практике нам не нужно создавать новый список для отсортированных элементов, 
# мы будет обрабатывать крайнюю левую часть списка как отсортированный сегмент. 
# Затем мы ищем во всем списке наименьший элемент и меняем его на первый элемент.

# Теперь мы знаем, что первый элемент списка отсортирован, 
# мы получаем наименьший элемент из оставшихся элементов и заменяем его вторым элементом. 
# Это повторяется до тех пор, пока последний элемент списка не станет оставшимся элементом для изучения.

# Реализация Selection Sort
def selection_sort(nums):  
    # значение i соответствует тому, сколько значений было отсортировано
    for i in range(len(nums)):
        # Мы предполагаем, что первый элемент несортированного сегмента является наименьшим
        lowest_value_index = i
        # Этот цикл перебирает несортированные элементы
        for j in range(i + 1, len(nums)):
            # по мере того как i увеличивается, нам нужно проверять все меньше элементов.
            if nums[j] < nums[lowest_value_index]:
                lowest_value_index = j
        # Поменять местами значения самого низкого несортированного элемента с первым несортированным
        nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]

# Проверяем, что это работает
random_list_of_nums = [12, 8, 3, 20, 11]  
selection_sort(random_list_of_nums)  
print(random_list_of_nums)  

# Сложность сортировки выбором в среднем составляет O(n^2).

```

## Сортировка перемешиванием (cocktail sort, shaker sort)

Сортировка перемешиванием (cocktail sort, shaker sort), или шейкерная сортировка – это усовершенствованная разновидность сортировки пузырьком, при которой сортировка производиться в двух направлениях, меняя направление при каждом проходе.

Проанализировав алгоритм пузырьковой сортировки, можно заметить:
- если при обходе части массива не было обменов элементов, то эту часть можно исключить, так как она уже отсортирована;
- при проходе от конца массива к началу минимальное значение сдвигается на первую позицию, при этом максимальный элемент перемещается только на один индекс вправо.

Исходя из приведенных идей, модифицируем сортировку пузырьком следующим образом:
- на каждой итерации, фиксируем границы части массива в которой происходит обмен;
- массив обходиться поочередно от начала массива к концу и от конца к началу;
При этом минимальный элемент перемещается в начало массива, а максимальный - в конец, после этого уменьшается рабочая область массива.

### Реализация шейкерной сортировки
```py

def shaker_sort(array): 
    length = len(array) 
    swapped = True
    start_index = 0
    end_index = length - 1
    
    while (swapped == True): 
        
        swapped = False
          
        # проход слева направо
        for i in range(start_index, end_index): 
            if (array[i] > array[i + 1]) : 
                # обмен элементов
                array[i], array[i + 1] = array[i + 1], array[i] 
                swapped = True
  
        # если не было обменов прерываем цикл
        if (not(swapped)): 
            break

        swapped = False

        end_index = end_index - 1
  
        #проход справа налево
        for i in range(end_index - 1, start_index - 1, -1): 
            if (array[i] > array[i + 1]): 
                # обмен элементов
                array[i], array[i + 1] = array[i + 1], array[i] 
                swapped = True
 
        start_index = start_index + 1

print("Шейкерная сортировка")
arr = []
length = int(input("Введите длину массива: ")) 
for i in range(0, length): 
    element = int(input("arr[" + str(i + 1) + "] = "))   
    arr.append(element)
shaker_sort(arr) 
print("Отсортированный массив: ") 
print(arr)

```
## Сортировка вставками (Insertion Sort)
Сортировка вставками (insertion sort) - это алгоритм сортировка, в котором все элементы массива просматриваются поочередно, при этом каждый элемент размещается в соответственное место среди ранее упорядоченных значений.

Алгоритм Insertion Sort сегментирует список на отсортированные и несортированные части. Он перебирает несортированный сегмент и вставляет просматриваемый элемент в правильную позицию отсортированного списка.

Сортировка вставками (Insertion Sort) простой алгоритм, интуитивно понятен и прост в реализации, но он очень медленный для больших массивов и поэтому почти никогда не используется для сортировки реальных данных.

Алгоритм работы сортировки вставками заключается в следующем:
- в начале работы упорядоченная часть пуста;
- добавляем в отсортированную область первый элемент массива из неупорядоченных данных;
- переходим к следующему элементу в не отсортированных данных, и находим ему правильную позицию в - отсортированной части массива, тем самым мы расширяем область упорядоченных данных;
повторяем предыдущий шаг для всех оставшихся элементов.

### Реализация сортировки вставками
```py

def insertion_sort(array): 
    length = len(array) 
    for i in range(1, length):
        key = array[i]
        j = i
        while (j - 1 >= 0) and (array[j - 1] > key):
            array[j - 1], array[j] = array[j], array[j - 1]
            j = j - 1
        array[j] = key

print("Сортировка вставками")
arr = []
length = int(input("Введите длину массива: ")) 
for i in range(0, length): 
    element = int(input("arr[" + str(i + 1) + "] = "))   
    arr.append(element)
insertion_sort(arr) 
print("Отсортированный массив: ") 
print(arr)

```

Insertion Sort является stable и in-place алгоритмом, который действительно хорошо работает только для почти отсортированных или небольших массивов.

### in-place: 
Требует небольшого постоянного дополнительного пространства памяти (независимо от входного размера коллекции),он перезаписывает исходные ячейки памяти элементов в коллекции.
### stable: 
Алгоритм поддерживает относительный порядок равных объектов из исходного массива. Другими словами, скажем, база данных сотрудников вашей компании возвращает двух сотрудников Дейв Уотсон и Дейв Браун в указанном порядке. Если бы вы отсортировали их по имени, stable алгоритм гарантирует, что этот порядок останется неизменным.

Так же при сортировке вставками вам не обязательно нужно иметь весь массив заранее перед сортировкой. Алгоритм может получать по одному элементу в процессе сортировки. Это очень удобно, если нам нужно добавлять больше элементов во время сортировки — алгоритм будет вставлять новый элемент элемент в нужное место без «повторного выполнения» сортировки всего массива.

Сортировка вставками может используется на практике из-за ее эффективности для небольших (~ 10 элементов) наборов данных.

Предполагается, что первый элемент списка отсортирован. Затем мы переходим к следующему элементу, назовем его х. Если x больше первого элемента, мы оставляем его как есть. Если x меньше, мы копируем значение первого элемента во вторую позицию и затем устанавливаем первый элемент в x.

Когда мы переходим к другим элементам несортированного сегмента, мы непрерывно перемещаем более крупные элементы в отсортированном сегменте вверх по списку, пока не встретим элемент меньше x, или не достигнем конца отсортированного сегмента, а затем поместим x в его правильное положение.

Массив разбивается на отсортированный подмассив и несортированный подмассив. В начале отсортированный подмассив содержит только первый элемент нашего исходного массива.

Первый элемент в несортированном массиве оценивается так, что мы можем вставить его на свое место в отсортированном подмассиве.

Вставка выполняется путем перемещения всех элементов которые больше, чем новый элемент, на одну позицию вправо.

Это продолжается, пока весь наш массив не будет отсортирован.

когда мы говорим, что элемент больше или меньше, чем другой элемент — это не обязательно означает большие или меньшие целые числа.
Мы можем определить слова больше и меньше, как нам нравится при использовании пользовательских объектов. Например, точка A может быть больше, чем точка B, если она находится дальше от центра системы координат.

используем следующий массив для иллюстрации алгоритма:
8, 5, 3, 11, 9
1 шаг: добавить 8 в отсортированный подмассив.
8, 5, 3, 11, 9
Теперь рассмотрим первый несортированный элемент — 5. Мы сохраняем это значение в отдельной переменной current. 5 меньше 8. Мы перемещаем 8 на одно место вправо, перезаписывая 5:
8, 8, 3, 11, 9 (current = 5)
5 меньше всех элементов в нашем отсортированном подмассиве, поэтому мы вставляем его на первую позицию:
5, 8, 3, 11, 9
Далее мы смотрим на номер 4. Мы сохраняем это значение в current. 4 меньше 8, поэтому мы перемещаем 8 вправо и делаем то же самое с 5.
5, 5, 8, 11, 9 (current = 3)
Мы снова столкнулись с элементом, меньшим, чем весь наш отсортированный подмассив, поэтому мы поместили его на первую позицию:
3, 5, 8, 11, 9
10 больше, чем наш самый правый элемент в отсортированном подмассиве, и поэтому больше, чем любой из элементов слева от 8. Поэтому мы просто переходим к следующему элементу:
3, 5, 8, 11, 9
9 меньше 10, поэтому мы переместимся на 10 вправо:
3, 5, 8, 11, 10 (current = 9)
Однако 9 больше 8, поэтому мы просто вставляем 9 сразу после 8.
3, 5, 8, 9, 11

## Реализация Insertion Sort
### Реализация Insertion Sort на простом массиве целых чисел.

INSERTION-SORT(A)
   for i = 1 to n
     key ← A [i]
      j ← i – 1
     while j > = 0 and A[j] > key
       A[j+1] ← A[j]
       j ← j – 1
     End while 
     A[j+1] ← key
  End for 


## Сортировка массивов
def insertion_sort(nums):  
    # Начнем со второго элемента, так как мы предполагаем, что первый элемент отсортирован
    for i in range(1, len(nums)):
        item_to_insert = nums[i]
        # И сохранить ссылку на индекс предыдущего элемента
        j = i - 1
        # Переместить все элементы отсортированного сегмента вперед, если они больше, чем элемент для вставки
        while j >= 0 and nums[j] > item_to_insert:
            nums[j + 1] = nums[j]
            j -= 1
        # Вставляем элемент
        nums[j + 1] = item_to_insert

# Проверяем, что это работает
random_list_of_nums = [9, 1, 15, 28, 6]  
insertion_sort(random_list_of_nums)  
print(random_list_of_nums)  


Сортировка массивов
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >=0 and key < arr[j] :
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key 
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print ("Sorted array is:")
for i in range(len(arr)):
    print arr[i]

# заполним простой массив и отсортируем его:

array = [4, 22, 41, 40, 27, 31, 36, 1, 42, 39, 14, 9, 3, 6, 34, 9, 21, 4, 29, 49]
insertion_sort(array)
print("sorted: " + str(array))
Вывод:
sorted: [1, 3, 4, 4, 6, 9, 9, 14, 21, 22, 27, 29, 31, 34, 36, 39, 40, 41, 42, 49]

Сортировка вставками может показаться медленным алгоритмом, и, действительно, в большинстве случаев он слишком медленный для любого практического использования с его временной сложностью O(n2). Однако, он очень эффективный для небольших массивов и почти отсортированных массивов.

Это делает сортировку вставками очень актуальной для использования в сочетании с алгоритмами, которые хорошо работают с большими наборами данных.

Сложность сортировки вставками в среднем равна O(n^2).


## Сортировка по частям (Stooge sort)
Сортировка по частям (Stooge sort) – рекурсивный алгоритм сортировки массива.

Алгоритм сортировки stooge sort заключается в следующем:
- Если значение последнего элемента массива меньше, чем значение первого элемента, то меняем их местами;
- Если в массиве содержится три и более элемента, то:
- Рекурсивно вызываем метод для первых 2⁄3 элементов;
- Рекурсивно вызываем метод для последних 2⁄3 элементов;
- Снова рекурсивно вызываем метод для первых 2⁄3 элементов;
```py

# Реализация сортировки по частям
def stooge_sort(array, l, h): 
    if l >= h:
        return
 
    if array[l] > array[h]:
        array[l],array[h] = array[h],array[l]
  
    if h - l + 1 > 2:
        t = (int)((h - l + 1) / 3)
        # рекурсивный вызов для первых 2/3
        stooge_sort(array, l, h - t)
        # рекурсивный вызов для последних 2/3
        stooge_sort(array, l + t, h)
        # рекурсивный вызов для первых 2/3
        stooge_sort(array, l, h - t)

print("Сортировка по частям")
array = []
length = int(input("Введите длину массива: ")) 
for i in range(0, length): 
    element = int(input("arr[" + str(i + 1) + "] = "))   
    array.append(element)
stooge_sort(array, 0, len(array) - 1) 
print("Отсортированный массив: ") 
print(array)

```
## Пирамидальная сортировка (Heap Sort) (Сортировка кучей) 
Этот популярный алгоритм сортировки, как сортировки вставками и выбором, сегментирует список на отсортированные и несортированные части. Он преобразует несортированный сегмент списка в структуру данных типа куча (heap), чтобы мы могли эффективно определить самый большой элемент.

Мы начинаем с преобразования списка в Max Heap — бинарное дерево, где самым большим элементом является корневой узел. Затем мы помещаем этот элемент в конец списка. Затем мы восстанавливаем нашу Max Heap, которая теперь имеет на одно меньшее значение, помещая новое наибольшее значение перед последним элементом списка.

Мы повторяем этот процесс построения кучи, пока все узлы не будут удалены.

### Реализация Heap Sort
Мы создаем вспомогательную функцию heapify для реализации этого алгоритма:
```py

def heapify(nums, heap_size, root_index):  
    # Предположим, что индекс самого большого элемента является корневым индексом
    largest = root_index
    left_child = (2 * root_index) + 1
    right_child = (2 * root_index) + 2
    # Если левый потомок корня является допустимым индексом, а элемент больше
    # чем текущий самый большой элемент, то обновляем самый большой элемент
    if left_child < heap_size and nums[left_child] > nums[largest]:
        largest = left_child
    # Делайте то же самое для right_child
    if right_child < heap_size and nums[right_child] > nums[largest]:
        largest = right_child
    # Если самый большой элемент больше не является корневым элементом, меняем их местами
    if largest != root_index:
        nums[root_index], nums[largest] = nums[largest], nums[root_index]
        # Heapify the new root element to ensure it's the largest
        heapify(nums, heap_size, largest)
def heap_sort(nums):  
    n = len(nums)
    # Создаем Max Heap из списка
    # Второй аргумент означает, что мы останавливаемся на элементе перед -1, то есть на первом элементе списка.
    # Третий аргумент означает, что мы повторяем в обратном направлении, уменьшая количество i на 1
    for i in range(n, -1, -1):
        heapify(nums, n, i)
    # Перемещаем корень max hea в конец
    for i in range(n - 1, 0, -1):
        nums[i], nums[0] = nums[0], nums[i]
        heapify(nums, i, 0)
# Проверяем, что все работает
random_list_of_nums = [35, 12, 43, 8, 51]  
heap_sort(random_list_of_nums)  
print(random_list_of_nums)  

```
В среднем сложность сортировки кучи составляет O(nlog (n)).

## Сортировка слиянием (Merge Sort)
Сортировка слиянием (Merge Sort) — один из самых известных алгоритмов сортировки. Merge Sort вместе с Quick Sort, вероятно, является первым эффективным алгоритмом сортировки общего назначения. Quick Sort -  классический пример алгоритма разделяй и властвуй (divide-and-conquer). 

Алгоритм разделяй и властвуй разбивает список пополам и продолжает разбивать список на пары, пока в нем не будут только одиночные элементы.

Соседние элементы становятся отсортированными парами, затем отсортированные пары объединяются и сортируются с другими парами. Этот процесс продолжается до тех пор, пока мы не получим отсортированный список со всеми элементами несортированного списка.

### Алгоритм сортировки слиянием работает так:

Мы рекурсивно разделяем список пополам, пока не получим списки с одиночным размером. Если массив имеет нечетное количество элементов, одна из этих половин на один элемент больше, чем другая. 

Подмассивы делятся снова и снова на две половины, пока вы не получите массивы, которые имеют только один элемент каждый.

Затем вы объединяете пары одноэлементных массивов в двухэлементные массивы, сохраняя их в процессе. Затем эти отсортированные пары объединяются в четырехэлементные массивы и так далее до тех пор, пока не будет получен исходный отсортированный массив.

Сортировка осуществляется путем сравнения наименьших элементов каждой половины. Первый элемент каждого списка сравнивается с первым. Если первая половина начинается с меньшего значения, то мы добавляем ее в отсортированный список. Затем мы сравниваем второе наименьшее значение первой половины с первым наименьшим значением второй половины.

Каждый раз, когда мы выбираем меньшее значение в начале половины, мы перемещаем индекс, элемент которого нужно сравнить на единицу.

Существует два основных способа реализации алгоритма сортировки слиянием, один из которых использует подход сверху вниз.
Другой подход, восходящий, работает в противоположном направлении, без рекурсии (итеративно) — если наш массив имеет N элементов, мы делим его на N подмассивов одного элемента и сортируем пары смежных одноэлементных массивов, затем сортируем соседние пары двухэлементных массивов и т. д.

Основная часть обоих этих подходов заключается в том, как мы объединяем (merge) два меньших массива в больший массив. 

```py

def merge(left_list, right_list):  
    sorted_list = []
    left_list_index = right_list_index = 0
    # создавать переменные для длины списков
    left_list_length, right_list_length = len(left_list), len(right_list)
    for _ in range(left_list_length + right_list_length):
        if left_list_index < left_list_length and right_list_index < right_list_length:
            # проверяем, какое значение с начала каждого списка меньше
            # Если элемент в начале левого списка меньше, добавляем его в отсортированный список
            if left_list[left_list_index] <= right_list[right_list_index]:
                sorted_list.append(left_list[left_list_index])
                left_list_index += 1
            # Если элемент в начале правого списка меньше, добавляем его в отсортированный список
            else:
                sorted_list.append(right_list[right_list_index])
                right_list_index += 1
        # Если мы достигли конца левого списка, добавляем элементы из правого списка
        elif left_list_index == left_list_length:
            sorted_list.append(right_list[right_list_index])
            right_list_index += 1
        # Если мы достигли конца правого списка, добавляем элементы из левого списка
        elif right_list_index == right_list_length:
            sorted_list.append(left_list[left_list_index])
            left_list_index += 1
    return sorted_list
def merge_sort(nums):  
    # Если список представляет собой один элемент, возвращаем его
    if len(nums) <= 1:
        return nums
    # Используем деление с округленим по наименьшему целому для получения средней точки, индексы должны быть целыми числами 
    mid = len(nums) // 2
    # Сортируем и объединяем каждую половину
    left_list = merge_sort(nums[:mid])
    right_list = merge_sort(nums[mid:])
    # Объединить отсортированные списки в новый
    return merge(left_list, right_list)
# Проверяем, что все работает
random_list_of_nums = [120, 45, 68, 250, 176]  
random_list_of_nums = merge_sort(random_list_of_nums)  
print(random_list_of_nums)  

# функция merge_sort() возвращает новый отсортированный список, а не сортирует существующий список.
# Поэтому для сортировки слиянием требуется пространство в памяти для создания нового списка того же размера, что и входной список.

```

## Быстрая сортировка (Quick Sort)
Быстрая сортировка является представителем трех типов алгоритмов: divide and conquer (разделяй и властвуй), in-place (на месте) и unstable (нестабильный).

При правильной настройке он чрезвычайно эффективен и не требует дополнительного пространства памяти как сортировка слиянием. 

1. Divide and conquer: Быстрая сортировка разбивает массив на меньшие массивы до тех пор, пока он не закончится пустым массивом, или массивом, содержащим только один элемент, и затем все рекурсивно соединяется в сортированный большой массив.
2. In place: Быстрая сортировка не создает никаких копий массива или его подмассивов. Однако этот алгоритм требует много стековой памяти для всех рекурсивных вызовов, которые он делает.
3. Unstable: стабильный (stable) алгоритм сортировки — это алгоритм, в котором элементы с одинаковым значением отображаются в том же относительном порядке в отсортированном массиве, что и до сортировки массива. Нестабильный алгоритм сортировки не гарантирует этого, это, конечно, может случиться, но не гарантируется. Это может быть важным, когда вы сортируете объекты вместо примитивных типов. Например, представьте, что у вас есть несколько объектов Person одного и того же возраста, например, Дейва в возрасте 21 года и Майка в возрасте 21 года. Если бы вы использовали Quicksort в коллекции, содержащей Дейва и Майка, отсортированных по возрасту, нет гарантии, что Дейв будет приходить раньше Майка каждый раз, когда вы запускаете алгоритм, и наоборот.

```py

# Есть разные способы реализовать быструю сортировки
# мы выбрали схема Tony Hoare

def partition(nums, low, high):  
    # Мы выбираем средний элемент, в качестве опорного. Некоторые реализации выбирают
    # первый элемент или последний элемент или вообще случайный элемент.
    pivot = nums[(low + high) // 2]
    i = low - 1
    j = high + 1
    while True:
        i += 1
        while nums[i] < pivot:
            i += 1
        j -= 1
        while nums[j] > pivot:
            j -= 1
        if i >= j:
            return j
        # Если элемент в i (слева от оси) больше, чем
        # элемент в J (справа от оси), то поменять их местами
        nums[i], nums[j] = nums[j], nums[i]

def quick_sort(nums):  
    # Создаем вспомогательную рекурсивную функцию
    def _quick_sort(items, low, high):
        if low < high:
            # Это индекс после опорного элемента, по которому наши списки разделены
            split_index = partition(items, low, high)
            _quick_sort(items, low, split_index)
            _quick_sort(items, split_index + 1, high)
    _quick_sort(nums, 0, len(nums) - 1)


# Проверяем, что все работает
# Быстрая сортировка является естественным рекурсивным алгоритмом — разделите входной массив на меньшие массивы, переместите элементы в нужную сторону оси и повторите.
random_list_of_nums = [22, 5, 1, 18, 19, 19, 99]  
quick_sort(random_list_of_nums)  
print(random_list_of_nums)  
# Поскольку алгоритм unstable (нестабилен), нет никакой гарантии, что два 19 будут всегда в этом порядке друг за другом.

```
## Базовая версия алгоритма делает следующее:

Разделяет коллекцию на две (примерно) равные части, принимая псевдослучайный элемент и использовать его в качестве опоры (центра деления). Элементы, меньшие, чем опора, перемещаются влево от опоры, а элементы, размер которых больше, чем опора, справа от него. Этот процесс повторяется для коллекции слева от опоры, а также для массива элементов справа от опоры, пока весь массив не будет отсортирован.

Когда мы описываем элементы как больше или меньше, чем другой элемент — это не обязательно означает большие или меньшие целые числа, мы можем отсортировать по любому выбранному нами свойству.

К примеру, если у нас есть пользовательский класс Person, и у каждого человека есть имя и возраст, мы можем сортировать по имени (лексикографически) или по возрасту (по возрастанию или по убыванию).

Быстрая сортировка чаще всего не сможет разделить массив на равные части. Это потому, что весь процесс зависит от того, как мы выбираем опорный элемент. Нам нужно выбрать опору так, чтобы она была примерно больше половины элементов и, следовательно, примерно меньше, чем другая половина элементов. Каким бы интуитивным ни казался этот процесс, это очень сложно сделать.

Самый простой подход — просто выбрать первый (или последний) элемент, это приводит к быстрой сортировке на уже отсортированных (или почти отсортированных) массивах. Именно так большинство людей выбирают реализацию быстрой сортировки.

Цель состоит в том, чтобы переместить элементы так, чтобы все элементы, меньшие, чем опора, находились слева от него, а все более крупные элементы были справа от него. Меньшие и большие элементы не обязательно будут отсортированы, мы просто хотим, чтобы они находились на правильной стороне оси. Затем мы рекурсивно проходим левую и правую сторону оси.


## Встроенные функции сортировки Python
### метод sort()
```py

# Создадим новый список, чтобы отсортировать его содержимое с помощью метода sort():
 
apples_eaten_a_day = [2, 1, 1, 3, 1, 2, 2]  
apples_eaten_a_day.sort()  
print(apples_eaten_a_day) # [1, 1, 1, 2, 2, 2, 3]  

# можем использовать функцию sorted() для создания нового отсортированного списка:

apples_eaten_a_day_2 = [2, 1, 1, 3, 1, 2, 2]  
sorted_apples = sorted(apples_eaten_a_day_2)  
print(sorted_apples) # [1, 1, 1, 2, 2, 2, 3]  

# Оба списка сортируются в порядке возрастания
# можете отсортировать в порядке убывания, установив для флага реверса значение True:

# Reverse sort the list in-place
apples_eaten_a_day.sort(reverse=True)  
print(apples_eaten_a_day) # [3, 2, 2, 2, 1, 1, 1]
# Reverse sort to get a new list
sorted_apples_desc = sorted(apples_eaten_a_day_2, reverse=True)  
print(sorted_apples_desc) # [3, 2, 2, 2, 1, 1, 1]  
```
Функция sorted() может сортировать любой итеративный объект, который включает в себя — списки, строки, кортежи, словари, наборы (set) и пользовательские итераторы.

Встроенная функция сортировки реализуют алгоритм сортировки Тима. Этот алгоритм, основан на сортировке слиянием и сортировке вставкой.


## Сортировка списков
Начальной точкой будет список, содержащий 1 000 000 случайных целых чисел и созданный через модуль random:
```py

import random

arr = [random.randint(0, 50) for r in range(1_000_000)]
# Сгенерированные числа находятся в диапазоне от 0 (включительно) до 50 (включительно).

# Сначала сравним, сколько памяти потребляет каждая из функций. 
# Для отслеживания максимального использования памяти, используем встроенный модуль resource. Так как данный модуль позволяет отслеживать использование памяти для одного потока, мы запускаем сортировку списка в отдельном потоке. 
# Также можно использовать FunctionSniffingClass, включенный в репозитории.

# main.py
 
import random
import resource
import sys
import time
 
from sniffing import FunctionSniffingClass

# Для встроенных функций создаем две функции-обертки, чтобы была возможность передавать их в качестве аргументов в FunctionSniffingClass. 
  
def list_sort(arr):
    return arr.sort()
 
 
def sorted_builtin(arr):
    return sorted(arr)
 
 
if __name__ == "__main__":
    if len(sys.argv) != 2:
        sys.exit("Please run: python (sort|sorted)")
    elif sys.argv[1] == "sorted":
        func = sorted_builtin
    elif sys.argv[1] == "sort":
        func = list_sort
    else:
        sys.exit("Please run: python (sort|sorted)")
 
    # код теста Lib
    arr = [random.randint(0, 50) for r in range(1_000_000)]
    mythread = FunctionSniffingClass(func, arr)
    mythread.start()
 
    used_mem = 0
    max_memory = 0
    memory_usage_refresh = .005 # Секунды
 
    while(1):
        time.sleep(memory_usage_refresh)
        used_mem = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss)
        if used_mem > max_memory:
            max_memory = used_mem
 
        # Проверяет, завершен ли вызов функции
        if mythread.isShutdown():
            # Уберите знак комментария, если вы хотите увидеть результат
            # print(mythread.results)
            break;
 
print("\nMAX Memory Usage:", round(max_memory / (2 ** 20), 3), "MB")

# $ python main.py sort
# $ python main.py sorted

# функция sorted() потребляет примерно на 32% больше памяти, чем метод list.sort(). 
```
## Скорость сортировки в Python
Для измерения времени выполнения обеих функций-оберток используем сторонний модуль boxx. Следующий код показывает, как можно использовать функцию timeit() для измерения времени выполнения обеих функций.
```py

import random
 
from boxx import timeit
 
 
def list_sort(arr):
    return arr.sort()
 
 
def sorted_builtin(arr):
    return sorted(arr)
 
 
def main():
    arr = [random.randint(0, 50) for r in range(1_000_000)]

    # сначала лучше запустить функцию sorted_builtin(), так как метод list.sort() сразу сортирует список, поэтому функции sorted() больше ничего не нужно сортировать.
    with timeit(name="sorted(list)"):
        sorted_builtin(arr)
 
    with timeit(name="list.sort()"):
        list_sort(arr)
 
 
if __name__ == "__main__":
    main()


```
Байтовый код обеих функций практически идентичен. Единственное различие в том, что функция list_sort() сначала загружает список, и за методом (sort) следует вызванный метод списка без аргументов. Если сравнить, функция sorted_builtin() сначала загружает встроенную функцию sorted(), а за ней следует список и вызов загруженной функции со списком в качестве аргумента.
 
Кроме того, оба варианта используют одинаковый алгоритм сортировки Timesort. В обоих используется одинаковый алгоритм сортировки, байтовый код обоих также практически идентичен.
