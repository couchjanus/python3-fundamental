## Сортировка слиянием (Merge Sort)
# Сортировка слиянием (Merge Sort) — один из самых известных алгоритмов сортировки. Merge Sort вместе с Quick Sort, вероятно, является первым эффективным алгоритмом сортировки общего назначения. Quick Sort -  классический пример алгоритма разделяй и властвуй (divide-and-conquer). 

# Алгоритм разделяй и властвуй разбивает список пополам и продолжает разбивать список на пары, пока в нем не будут только одиночные элементы.

# Соседние элементы становятся отсортированными парами, затем отсортированные пары объединяются и сортируются с другими парами. Этот процесс продолжается до тех пор, пока мы не получим отсортированный список со всеми элементами несортированного списка.

# Алгоритм сортировки слиянием работает так:
# Мы рекурсивно разделяем список пополам, пока не получим списки с одиночным размером. Если массив имеет нечетное количество элементов, одна из этих половин на один элемент больше, чем другая. 

# Подмассивы делятся снова и снова на две половины, пока вы не получите массивы, которые имеют только один элемент каждый.

# Затем вы объединяете пары одноэлементных массивов в двухэлементные массивы, сохраняя их в процессе. Затем эти отсортированные пары объединяются в четырехэлементные массивы и так далее до тех пор, пока не будет получен исходный отсортированный массив.

# Сортировка осуществляется путем сравнения наименьших элементов каждой половины. Первый элемент каждого списка сравнивается с первым. Если первая половина начинается с меньшего значения, то мы добавляем ее в отсортированный список. Затем мы сравниваем второе наименьшее значение первой половины с первым наименьшим значением второй половины.

# Каждый раз, когда мы выбираем меньшее значение в начале половины, мы перемещаем индекс, элемент которого нужно сравнить на единицу.


# Как вы можете видеть, тот факт, что массив не может быть разделен на равные половины, не является проблемой, 1 просто ждет, пока не начнется сортировка.

# Существует два основных способа реализации алгоритма сортировки слиянием, один из которых использует подход сверху вниз, и именно так чаще всего используется.

# Другой подход, то есть восходящий, работает в противоположном направлении, без рекурсии (итеративно) — если наш массив имеет N элементов, мы делим его на N подмассивов одного элемента и сортируем пары смежных одноэлементных массивов, затем сортируем соседние пары двухэлементных массивов и т. д.

# Основная часть обоих этих подходов заключается в том, как мы объединяем (merge) два меньших массива в больший массив. Это сделано довольно интуитивно, скажем, мы рассмотрим последний шаг в нашем предыдущем примере. У нас есть массивы:

# A: 4 7 9 10
# B: 1 3 6
# sorted: empty
# Первое, что мы сделаем, это посмотрим на первый элемент обоих массивов. Мы находим тот, который меньше, в нашем случае это 1, так что это первый элемент нашего отсортированного массива, и мы продвигаемся вперед в массиве B:

# A:  4 7 9 10
# B: 1 3 6
# sorted: 1
# Затем мы смотрим на следующую пару элементов 4 и 3; 3 меньше, поэтому мы помещаем его в наш отсортированный массив и перемещаемся вперед в массиве B. Конечно, мы не перемещаемся вперед в массиве A, и мы сохраняем наш указатель на 3 для будущих сравнений:

# A: 4 7 9 10
# B: 1 3 6
# sorted: 1 3
# Используя ту же логику, мы перемещаемся по остальным и получаем массив {1, 3, 4, 6, 7, 9, 10}.

# Возможны два особых случая:

# Оба подмассива имеют одинаковый элемент. Мы можем двигаться вперед в любом из них и добавить элемент в отсортированный массив. Мы можем технически продвинуться вперед в обоих массивах и добавить оба элемента в отсортированный массив, но это потребует особого поведения, когда мы встретим одинаковые элементы в обоих массивах.
# Мы исчерпали элементы в одном подмассиве. Например, у нас есть массив с {1, 2, 3} и массив с {11, 12, 13}. Ясно, что мы пройдемся по всем элементам первого массива, не продвигаясь вперед ни разу во втором. Всякий раз, когда у нас заканчиваются элементы в подмассиве, мы просто добавляем элементы второго за другим.

# Реализация
def merge(left_list, right_list):  
    sorted_list = []
    left_list_index = right_list_index = 0
    # создавать переменные для длины списков
    left_list_length, right_list_length = len(left_list), len(right_list)
    for _ in range(left_list_length + right_list_length):
        if left_list_index < left_list_length and right_list_index < right_list_length:
            # проверяем, какое значение с начала каждого списка меньше
            # Если элемент в начале левого списка меньше, добавляем его в отсортированный список
            if left_list[left_list_index] <= right_list[right_list_index]:
                sorted_list.append(left_list[left_list_index])
                left_list_index += 1
            # Если элемент в начале правого списка меньше, добавляем его в отсортированный список
            else:
                sorted_list.append(right_list[right_list_index])
                right_list_index += 1
        # Если мы достигли конца левого списка, добавляем элементы из правого списка
        elif left_list_index == left_list_length:
            sorted_list.append(right_list[right_list_index])
            right_list_index += 1
        # Если мы достигли конца правого списка, добавляем элементы из левого списка
        elif right_list_index == right_list_length:
            sorted_list.append(left_list[left_list_index])
            left_list_index += 1
    return sorted_list
def merge_sort(nums):  
    # Если список представляет собой один элемент, возвращаем его
    if len(nums) <= 1:
        return nums
    # Используем деление с округленим по наименьшему целому для получения средней точки, индексы должны быть целыми числами 
    mid = len(nums) // 2
    # Сортируем и объединяем каждую половину
    left_list = merge_sort(nums[:mid])
    right_list = merge_sort(nums[mid:])
    # Объединить отсортированные списки в новый
    return merge(left_list, right_list)
# Проверяем, что все работает
random_list_of_nums = [120, 45, 68, 250, 176]  
random_list_of_nums = merge_sort(random_list_of_nums)  
print(random_list_of_nums)  

# функция merge_sort() возвращает новый отсортированный список, а не сортирует существующий список.
# Поэтому для сортировки слиянием требуется пространство в памяти для создания нового списка того же размера, что и входной список.
