# ООП
Объектно-ориентированное программирование (ООП) является методологией разработки программного обеспечения, в основе которой лежит понятие класса и объекта, при этом сама программа создается как некоторая совокупность объектов, которые взаимодействую друг с другом и с внешним миром. 
Каждый объект является экземпляром некоторого класса. 
Классы образуют иерархии. Согласно Алану Кэю - автору Smalltalk - объектно-ориентированным называется язык, построенный с учетом следующих принципов:
- Все данные представляются объектами
- Программа является набором взаимодействующих объектов, посылающих друг другу сообщения
- Каждый объект имеет собственную часть памяти и может иметь в составе другие объекты
- Каждый объект имеет тип
- Объекты одного типа могут принимать одни и те же сообщения (и выполнять одни и те же действия)

## Объектно-ориентированная парадигма
Объектно-ориентированная парадигма программирования включает 3 основных принципа:
1. Инкапсуляция (Encapsulation) – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали внутренней реализации объектов и предохраняет целостность данных
2. Наследование (Inheritance) - аспект ООП, облегчающий повторное использование кода. Принцип наследования в языке программирования позволяет строить новые определения классов на основе существующих. Наследование позволяет расширять поведение базового класса (родительского или суперкласса), наследуя его основную функциональность в производном подклассе (дочернем классе или подклассе).
3. Полиморфизм (Polymorphism)– это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. В частности, этот принцип ООП позволяет базовому классу определять набор членов, которые доступны всем наследникам.
## Класс (Class)
Класс (Class): абстракция реального мира (обобщенный шаблон), специальный тип данных; класс описывает свойства и методы, которые могут быть доступны у подобных объектов;
Класс - универсальный, комплексный тип данных, состоящий из тематически единого набора полей (переменных более элементарных типов) и методов (функций для работы с этими полями), то есть он является моделью информационной сущности с внутренним и внешним интерфейсами для оперирования своим содержимым (значениями полей). 
В классах широко используются специальные блоки из одного или чаще двух спаренных методов, отвечающих за элементарные операции с определённым полем (интерфейс присваивания и считывания значения), которые имитируют непосредственный доступ к полю. Эти блоки называются свойствами и почти совпадают по конкретному имени со своим полем (например, имя поля может начинаться со строчной, а имя свойства - с заглавной буквы). 
## Объект (Object)
Объект (Object) (экземпляр класса, Class Instance): частный случай (отдельный представитель) класса, имеющий конкретное состояние и поведение, полностью определяемое классом. 
Объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе. 
Объект  - это нечто, что имеет тождественность и значение, а также определенный тип, обладает некими характеристиками и определенным поведением. Объекты наследуют многие из своих атрибутов от одного или более родительских классов.

Кроме ключевых слов и специальных символов (подобных таким операторам, как
```py
+, -, *, **, /, %, <, > и т. д.) 
```
все в Python является объектом. 

Сущность в адресном пространстве вычислительной системы, появляющаяся при создании экземпляра класса.
В Python объекты принято называть также экземплярами. Это связано с тем, что в нем все классы сами являются объектами класса type. 
Точно также все модули являются объектами класса module. Поэтому во избежании путаницы объекты, созданные на основе обычных классов, называют экземплярами. 
В Python все данные являются объектами.  Число 2 представляется объектом «число 2», строка 'hello' – это объект «строка 'hello'».
Каждый объект относится к какому-то типу.  Строки хранятся в объектах типа str, целые числа хранятся в объектах типа int, дробные числа (вещественные числа) — в объектах типа float.  Тип объекта определяет, какие действия можно делать с объектами этого типа. 

## Добавить новый тип Python
Добавить новый тип Python можно либо написав класс (class), либо определив новый тип в модуле расширения (например, написанном на языке C). 
Класс является шаблоном или формальным описанием объекта, а объект представляет экземпляр этого класса, его реальное воплощение.
Для определения класса используется оператор class:
```py
class имя_класса(parent class 1, parent class 2, ...):
   # определения атрибутов и методов класса
```

У класса могут быть базовые (родительские) классы (parent class), которые, если они есть, указываются в скобках после имени определяемого класса.
```py
# Минимально возможное определение класса выглядит так:
class A:
   pass

```
### Каждый класс содержит и описывает поля и методы:
- Поле (Data Member / Variable / Field): переменная, привязанная к классу;
- Метод (Method): действие (функция), которую можно проводить над классом.
## Интерфейс
Интерфейс – это набор методов, доступных для использования другими классами.
Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.
Определения атрибутов - обычные операторы присваивания, которые связывают некоторые значения с именами атрибутов.
```py
class A:
   attr = 2 * 2

```
Доступ к полям и методам осуществляется в Python через указание объекта, используя точку

Определения методов (method) аналогичны определениям функций, но (за некоторыми исключениями) методы всегда имеют первый аргумент, называемый по общепринятому соглашению self:
```py

class A:
   def my_method(self, x):
       # блок кода метода
       pass
```

В языке Python класс не является чем-то статическим, поэтому добавить атрибуты можно и после определения:
```py

class A:
   pass

def my_method1(self, x):
   return x * x
A.m1 = my_method
A.attr1 = 2 * 2

```
Объект создается путем вызова класса по его имени. При этом после имени класса обязательно ставятся скобки:
Для создания объекта - экземпляра класса (инстанцирования класса), достаточно вызвать класс по имени и задать параметры конструктора: ИмяКласса()
```py

class A:
   attr = 2 * 2
Доступ к атрибуту:
a = A()
print(a.attr)

```
Механизм извлечения имён может быть реализован по разному для различных типов:
1. Если объект является модулем, список будет содержать имена атрибутов модуля;
2. Если объект является типом или классом, список будет содержать имена атрибутов данного объекта и его родителей (вычисляются рекурсивно).
```py
print(dir(A))
```
3. В других случаях список будет содержать имена атрибутов самого объекта, его класса, и классов-родителей (вычисляются рекурсивно).
```py
print(dir(a))
```

Классы, как и функции, могут быть документированы сразу после определения заголовка класса с помощью doc strings. Вводятся они с помощью тройных кавычек:
```py

class Y:
   """The vertical motion of a ball."""
   val = "hello"

```
В случае объемного конечного продукта обычно пишут более исчерпывающее объяснение о том как этот класс может быть использован, какие методы и атрибуты включает, примеры использования класса
```py

   """Mathematical function for the vertical motion of a ball.
   Methods:
       constructor(v0): set initial velocity v0.
       value(t): compute the height as function of t.
       formula(): print out the formula for the height.
   Attributes:
       v0: the initial velocity of the ball (time 0).
       g: acceleration of gravity (fixed).

```
## Специальные методы
Методы, имена которых обрамляются __, Python трактует как специальные, например, __init__ (инициализация) или __str__ (строковое представление). Специальные методы, как правило, идут первыми при объявлении класса.
В Python наличие пар знаков подчеркивания спереди и сзади в имени метода говорит о том, что он принадлежит к группе методов перегрузки операторов. 
Если подобные методы определены в классе, то объекты могут участвовать в таких операциях как сложение, вычитание, вызываться как функции и др.
При этом методы перегрузки операторов не надо вызывать по имени. Вызовом для них является сам факт участия объекта в определенной операции. 
В случае конструктора класса – это операция создания объекта. Так как объект создается в момент вызова класса по имени, то в этот момент вызывается метод __init__(), если он определен в классе.

## Инстанцирование объекта
Специальные методы вызываются при создании экземпляра класса (конструктор), при инициализировании экземпляра класса (инициализатор) и при удалении класса (деструктор). 
В языке Python реализовано автоматическое управление памятью, поэтому инициализатор и деструктор требуются достаточно редко, для ресурсов, требующих явного освобождения.

## метод __init__
Инстанцирование обычного объекта происходит в 2 этапа:  сначала его создание, потом инициализация.  Соответственно, сначала запускается метод класса __new__, который возвращает объект данного класса, потом выполняется метод класса __init__, который инициализирует уже созданный объект.
```py
__new__(cls[, ...]) - # управляет созданием экземпляра. 
```

В качестве обязательного аргумента принимает класс.  
Принимает в качестве параметров любые другие аргументы, которые будут переданы в __init__. 
Должен возвращать экземпляр класса для его последующей его передачи методу __init__.
Это первый метод, который будет вызван при инициализации объекта. 

## Конструктор
В объектно-ориентированном программировании конструктором класса называют метод, который автоматически вызывается при создании объектов. 
Его также можно назвать конструктором объектов класса. Имя такого метода обычно регламентируется синтаксисом конкретного языка программирования. Так в Java имя конструктора класса совпадает с именем самого класса. 

В Python роль конструктора играет инициализатор класса - метод __init__().
 __init__ почти повсеместно используется при определении классов.
Конструктору вовсе не обязательно принимать какие-либо параметры, не считая self. Значения полям могут назначаться как угодно. 
Не обязательно, чтобы в конструкторе происходила установка атрибутов объекта. Там может быть, например, код, который порождает создание объектов других классов.
```py

class Person:
   def __init__(self, first_name, last_name):
       self.first_name = first_name
       self.last_name = last_name

sam = Person("Sam", "Brown")

```
Если мы попытаемся создать объект, не передав ничего в конструктор, то будет возбуждено исключение, и объект не будет создан:
```py

# конструктор класса не позволит создать объект без обязательных полей:
p1 = Person()

```
Если надо создать объект без обязательных полей, параметрам конструктора класса задаются значения по умолчанию:
```py

   def __init__(self, first_name, last_name, favorite=1, note=''):

```
При вызове класса в круглых скобках передаются значения, которые будут присвоены параметрам метода __init__(). 

Первый параметр self метода __init__() – ссылка на сам только что созданный объект.
Внутри конструктора init аргумент self это переменная, содержащая создаваемый экземпляр. 
Когда мы пишем в теле конструктора self.first_name = first_name, мы в действительности инициализируем sam.first_name.

### Любой метод класса содержит self в качестве первого аргумента.
Другой метод или атрибут класса используют self в виде self.name, где name - имя этого атрибута или метода.
self в качестве аргумента пропускается при вызове методов класса

Помимо конструктора объектов в языках программирования есть обратный ему метод – деструктор. Он вызывается, когда объект уничтожается.
В Python объект уничтожается, когда исчезают все связанные с ним переменные или им присваивается другое значение, в результате чего связь со старым объектом теряется. 
В классах Python функцию деструктора выполняет метод __del__().
```py

object.__del__(self)
self -- Ссылка на экземпляр.

```
Вызывается интерпретатором, когда экземпляр назначен к уничтожению. Также известен под именем деструктор. Если метод определен в базовом классе, то потомок должен вызывать его явно, чтобы удаление части экземпляра, реализуемой базовым классом произошло без ошибок.

Вызов del x не приводит напрямую к вызову x.__del__(), а лишь уменьшает значение счетчика ссылок на единицу. Метод будет вызван, только когда счетчик ссылок достигнет нуля.
Ввиду того, что вызов метода зависит от множества обстоятельств, исключения, возбуждаемые в ходе его исполнения игнорируются, при этом в sys.stderr пишется предупреждение.
Кроме того, когда метод вызывается как реакция на удаление модуля (например, когда выполнение программы завершено), другие глобальные переменные, которые могут быть использованы в методе могут быть уже удалены или находится в процессе удаления (например, при завершение работы механизма импорта). Python гарантирует, что глобальные переменные, имена которых начинаются с одиночного почерка, удаляются из модуля прежде остальных. 
```py

class Line:
   def __new__(cls):
       return super(Line, cls).__new__(cls)
   def __init__(self, p1, p2):
       self.line = (p1, p2)
   def __del__(self):
       print("Удаляется линия %s - %s" % self.line)

l = Line((0.0, 1.0), (0.0, 2.0))
del l # Удаляется линия (0.0, 1.0) - (0.0, 2.0)

from os.path import join
class FileObject:
   '''Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.'''
   def __init__(self, filepath='~', filename='sample.txt'):
       # открыть файл filename в filepath в режиме чтения и записи
       self.file = open(join(filepath, filename), 'r+')
   def __del__(self):
       self.file.close()
       del self.file

```
## Метод __str__
Метод __str__ - специальный метод, возвращающий строковое представление класса.
```py

class Point:
   """point on the plane."""

   # Строковое представление класса
   def __str__(self):
       """Вернуть строку в виде 'Точка 2D (x, y)'."""
       return "Точка 2D ({}, {})".format(self.x, self.y)
if __name__ == "__main__":
   p = Point(3, 4)
   print(p)  # Точка 2D (3, 4)

```
Если метод __str__ не реализован, выводится строковое представления класса по умолчанию (содержит имя класса).

Специальные методы могут быть использованы, если необходимо добавить возможность выполнения стандартных операций над классами (например, сложить 2 класса-точки или обратить ее координаты).
## Переопределение операций для класса
```py

class Point:
   """point on the plane."""

   def __add__(self, other):
       """Создать новый объект как сумму координат 'self' и 'other'."""
       return Point(self.x + other.x, self.y + other.y)

def __sub__(self, other):
       """Создать новый объект как разность координат 'self' и 'other'."""
      
       # Вместо Point можно использовать self.__class__,
       # что позволит не привязываться к имени класса и быть
       # валидным для потомков
       return self.__class__(self.x - other.x, self.y - other.y)

   # Если Python не найдет в определении класса метода '__add__()',
   # будет сгенерировано исключение:
   # 'TypeError: unsupported operand type(s) for +: 'Point' and 'Point''

   print(p1 + p2)             # Точка 2D (-5, 15)

Отрицание __neg__(a)
Сложение __add__(a, b)
Вычитание __sub__(a, b)
Умножение __mul__(a, b)
Деление __truediv__(a, b)
Целочисленное деление __floordiv__(a, b)
Остаток от деления __mod__(a, b)
Возведение в степень __pow__(a, b)
Срез __getitem__(seq, slice(i, j))
Конкатенация __concat__(seq1, seq2)
Идентификация __is__(a, b) __is_not__(a, b)
Проверка на вхождение __contains__(seq, obj)
Преобразование в логический тип __truth__(obj)
Равенство __eq__(a, b)
Сравнение __lt__(a, b)

```

В виду того, что точный тип передаваемых аргументов не известен (Python - язык с неявной динамической типизацией), могут возникнуть проблемы при передаче не ожидаемых значений.
```py

# Ошибка при попытке сложить Point и int
if __name__ == "__main__":

   p1 = Point(0, 5)
   p2 = Point(-5, 10)

   print(p1 + 2)  # Ошибка: AttributeError: 'int' object has no attribute 'x'

```
Перед действием рекомендуется проверить, экземпляром какого класса является переданный объект. Выполнить такую проверку можно используя функции type() или isinstance(obj, class).
```py

def __add__(self, other):
       """Создать новый объект как сумму координат self и other."""

       if isinstance(other, self.__class__):
           # Точка с точкой
           # Возвращаем новый объект!
           return Point(self.x + other.x, self.y + other.y)
       elif isinstance(other, (int, float)):
           # Точка и число
           # Добавим к обеим координатам self число other и вернем результат
           # Возвращаем старый, измененный, объект!
           self.x += other
           self.y += other
           return self
       else:
           # В противном случае возбуждаем исключение
           raise TypeError("Не могу добавить {1} к {0}".
                           format(self.__class__, type(other)))

```
Все значения в Python являются объектами, инкапсулирующими методы и данные и предоставляющие пользователям общедоступный интерфейс. Методы и данные объекта доступны через его атрибуты.
Сокрытие информации о внутреннем устройстве объекта выполняется в Python на уровне соглашения между программистами о том, какие атрибуты относятся к общедоступному интерфейсу класса, а какие — к его внутренней реализации. 

Одиночное подчеркивание в начале имени атрибута говорит о том, что метод не предназначен для использования вне методов класса (или вне функций и классов модуля), однако, атрибут все-таки доступен по этому имени:  
```py
self._mobile = mobile_phone
```

Два подчеркивания в начале имени дают несколько большую защиту: атрибут перестает быть доступен по этому имени.
```py
  self.__private = private_phone
```
     
В ряде языков, например, С++, существует четкое разделение членов класса на закрытые, защищенные и публичные. 

В Python все члены класса являются общедоступными, хотя существует возможность эмуляции закрытых. 

Концепция отсутствия закрытых атрибутов в Python описывается фразой одного из разработчиков языка: «Мы все взрослые люди. Если программист хочет выстрелить себе в ногу - нужно предоставить ему возможность это сделать».

В Python регулирование открытости и закрытости атрибутов определяется конвенцией.
Атрибут, который должен быть не общедоступным (Non-Public) обозначается при помощи ведущего подчеркивания: 
```py

_spam для поля 
или 
_get_count() для метода. 

```
Данный синтаксис указывает на то, что атрибут используется для внутренней реализации класса и не предназначен для использования извне и должен быть использован/изменен только если разработчик-пользователь класса абсолютно уверен в этом. 

При этом атрибут с _ доступен извне, как и обычный public-атрибут класса.

Атрибут, который должен быть закрытым (Private), обозначается при помощи ведущего двойного подчеркивания: 
```py

__private для поля 
или 
__get_count() для метода. 

```
Данный синтаксис указывает на то, что атрибут используется для внутренней реализации класса и не предназначен для использования извне и не должен быть использован/изменен разработчиком-пользователем класса. 
При этом атрибут с __ оказывается недоступным извне, используя технику сокрытия имен (Name Mangling). Несмотря на это, в отличие от ряда языков (например, Java) такие закрытые члены класса также можно изменять, но более сложным способом - их можно увидеть, используя функцию dir().

Организация доступа к членам класса в Python построена на принципе универсального доступа, гласящем, что «все услуги, предлагаемые модулем должны быть доступны через единую нотацию, которая не раскрывает, реализованы ли они посредством хранения либо вычисления».
В частности, это предполагает:
предоставлять доступ к переменным напрямую, например, foo.x = 0, а не foo.set_x(0);
в случае необходимости проверки устанавливаемого значения использовать свойства, которые сохраняют единый синтаксис доступа, установка значения foo.x = 0 приводит к вызову foo.set_x(0).

Преимуществом данного подхода является возможность использование синтаксиса foo.x += 1, хотя на самом деле внутри происходит вызов foo.set_x(foo.get_x() + 1).
## Методы set_... и get_
Методы вида set_... и get_... называются сеттерами и геттерами (Setter и Getter) и предназначены для защищенных установки и чтения значений атрибутов (т.е. прежде чем произойдет изменение атрибута код метода может выполнить какие-либо проверки). Данный подход используется в языках, в которых отсутствуют свойства.
```py

class Circle:
   def __init__(self, x=0, y=0, r=0):
       self.set_r(r)

   def get_r(self):
       return self._r
   def set_r(self, r):
       # Устаналиваем только положительный радиус
       assert r > 0, "Радиус должен быть положительным!"
       self._r = r

```
При описании предметной области классы могут образовывать иерархию, в корне которой стоит базовый класс, а нижележащие классы (подклассы) наследуют свои атрибуты и методы, уточняя и расширяя поведение вышележащего класса (надкласса). 
Если один класс наследует (расширяет) другой класс, то этот класс называется подкласс. А класс, который наследуется, называется суперкласс.
Если некоторый класс наследует другой суперкласс, то имя суперкласса задается в круглых скобках в заголовке инструкции class.
```py

class A: # Класс A - суперкласс для класса B
   # атрибуты класса A
class B(A): # Класс B - подкласс класса A
   # атрибуты класса B

# Подкласс наследует атрибуты своих суперклассов.

class  A:# Класс A - суперкласс для классов B, C
   # Атрибут класса A: метод super_m()
   def super_m(self):
       print("class A. Method super_m()")

class B(A): # Класс B - подкласс класса A
   # Атрибут класса B: Метод foo_m()
   def foo_m(self):
       # Из метода foo_m() можно доступиться к атрибуту super_m() класса A
       self.super_m() # будет вызвано A.super_m()
       print("class B. Method foo_m()")

class C(B): # Класс C - подкласс классов A, B

   def bar_m(self):   # Атрибут класса C: метод bar_m()
       # Из метода bar_m() можно доступиться
       # к атрибуту super_m() класса A
       # и к атрибуту foo_m() класса B.
       self.super_m()
       self.foo_m()
       print("class C. Method bar_m()")

# Тестирование работы механизма наследования
objA = A()
objA.super_m() # вызов метода super_m() класса A

print(p2) # <__main__.Person object at 0x7f8f9a4c52e8>

```
## Каждый объект имеет 2 специальных атрибута class и dict.
class - определяет класс или тип, экземпляром которого является объект. Класс объекта определяет его поведение; он есть у всех объектов, в том числе и встроенных. 
dict словарь, дающий доступ к внутреннему пространству имен, он есть почти у всех объектов, у многих встроенных типов его нет.
```py

print(dir(p2))
['_Person__address', '_Person__current_date', '_Person__private', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_age', '_date', '_email', '_favorite', '_first_name', '_last_name', '_mobile', '_note', '_office', '_time', 'add_email', 'add_favorite', 'add_mobile_phone', 'add_note', 'add_office_phone', 'add_private_phone', 'full_name', 'get_private_phone', 'print_contacts']

```
Атрибуты объекта можно условно разделить две группы: 
определенные python-ом (такие как __class__, __bases__) 
определенные пользователем.
```py

print (p2.__dict__)

{'_first_name': 'Dolche', '_last_name': 'Gabano', '_favorite': 1, '_note': None, '_mobile': None, '_office': '767828292', '_Person__private': '99999999', '_email': 'dg@dog.net', '_Person__address': None, '_age': None, '_date': '14/11/2019', '_time': '14:49:46'}

```
Атрибут __dict__ относится к системным (определенным python-ом) атрибутам. Его задача - хранить пользовательские атрибуты. 
Он представляет собой dictionary, в котором ключом является имя_атрибута, значением, соответственно, значение_атрибута. Поиск в __dict__ производится во время выполнения и при поиске учитывается __dict__ класса объекта и базовых классов. 

Дескриптор это атрибут объекта со “связанным поведением”, то есть такой атрибут, при доступе к которому его поведение переопределяется методом протокола дескриптора. Эти методы  __get__, __set__ и __delete__. Если хотя бы один из этих методов определен в объекте , то можно сказать что этот метод дескриптор.
Дескрипторы являются хорошим инструментом для привязки поведения к атрибутам. 
```py

# протокол дескрипторов появившийся в Python 3.6:
object.__set_name__(self, owner, name)
# Вызывается во время создания класса.
# В этом случае дескриптор назначается на имя атрибута.
# С этим протоколом, мы можем привязать имя атрибута к дескриптору


```

