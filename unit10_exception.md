# Обработка исключений в Python

Исключения (exceptions) - ещё один тип данных в python. Исключения необходимы для того, чтобы сообщать программисту об ошибках.

При возникновении ошибки времени выполнения Python создает (возбуждает) специальный объект - исключение, который позволяет однозначно характеризовать возникшую ошибочную ситуацию. 

## Иерархия встроенных в python исключений

- BaseException - базовое исключение, от которого берут начало все остальные.
    - SystemExit - исключение, порождаемое функцией sys.exit при выходе из программы.
    - KeyboardInterrupt - порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).
    - GeneratorExit - порождается при вызове метода close объекта generator.
    - Exception - а вот тут уже заканчиваются полностью системные исключения (которые лучше не трогать) и начинаются обыкновенные, с которыми можно работать.
       - StopIteration - порождается встроенной функцией next, если в итераторе больше нет элементов.
       - ArithmeticError - арифметическая ошибка.
         - FloatingPointError - порождается при неудачном выполнении операции с плавающей запятой. На практике встречается нечасто.
         - OverflowError - возникает, когда результат арифметической операции слишком велик для представления. Не появляется при обычной работе с целыми числами (так как python поддерживает длинные числа), но может возникать в некоторых других случаях.
         - ZeroDivisionError - деление на ноль.
       - AssertionError - выражение в функции assert ложно.
       - AttributeError - объект не имеет данного атрибута (значения или метода).
       - BufferError - операция, связанная с буфером, не может быть выполнена.
       - EOFError - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
       - ImportError - не удалось импортирование модуля или его атрибута.
       - LookupError - некорректный индекс или ключ.
            - IndexError - индекс не входит в диапазон элементов.
            - KeyError - несуществующий ключ (в словаре, множестве или другом объекте). 
       - MemoryError - недостаточно памяти.
       - NameError - не найдено переменной с таким именем.
            - UnboundLocalError - сделана ссылка на локальную переменную в функции, но переменная не определена ранее. 
       - OSError - ошибка, связанная с системой.
            - BlockingIOError
            - ChildProcessError - неудача при операции с дочерним процессом.
            - ConnectionError - базовый класс для исключений, связанных с подключениями.
                - BrokenPipeError
                - ConnectionAbortedError
                - ConnectionRefusedError
                - ConnectionResetError
            - FileExistsError - попытка создания файла или директории, которая уже существует.
            - FileNotFoundError - файл или директория не существует.
            - InterruptedError - системный вызов прерван входящим сигналом.
            - IsADirectoryError - ожидался файл, но это директория.
            - NotADirectoryError - ожидалась директория, но это файл.
            - PermissionError - не хватает прав доступа.
            - ProcessLookupError - указанного процесса не существует.
            - TimeoutError - закончилось время ожидания.
       - ReferenceError - попытка доступа к атрибуту со слабой ссылкой.
       - RuntimeError - возникает, когда исключение не попадает ни под одну из других категорий.
       - NotImplementedError - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
       - SyntaxError - синтаксическая ошибка.
             - IndentationError - неправильные отступы.
                 - TabError - смешивание в отступах табуляции и пробелов.
       - SystemError - внутренняя ошибка.
       - TypeError - операция применена к объекту несоответствующего типа.
       - ValueError - функция получает аргумент правильного типа, но некорректного значения.
       - UnicodeError - ошибка, связанная с кодированием / раскодированием unicode в строках.
             - UnicodeEncodeError - исключение, связанное с кодированием unicode.
             - UnicodeDecodeError - исключение, связанное с декодированием unicode.
             - UnicodeTranslateError - исключение, связанное с переводом unicode.
       - Warning - предупреждение.


### Наиболее распространенные Exception Errors:

- except IOError: print('Error occurred while opening the file.') - происходит при ошибках файловой системы, например, если файл не открывается.
- except ValueError: print('Non-numeric input detected.')- происходит, если функция получает аргумент правильного типа, но не подходящего значения.
- except ImportError: print('Unable to locate the module.') - Если модуль Python не может быть загружен или не найден.
- except EOFError: print('Identified EOF error.')- Возникает, если входные функции (input() / raw_input()) попадают в условие конца файла (EOF), но без чтения каких-либо данных.
- except KeyboardInterrupt: print('Wrong keyboard input.') - когда пользователь вводит ключ прерывания (т.е. Control-C или Del в консоли)
- except: print('An error occurred.')


## Пример встроенного возбуждения исключения:
```py

# ZeroDivisionError исключение:
# ZeroDivisionError (деление на ноль)
100 / 0
Traceback (most recent call last):
  File "", line 1, in
    100 / 0
ZeroDivisionError: division by zero

# TypeError исключение:
# TypeError (операция применена к объекту несоответствующего типа)
2 + '1'
Traceback (most recent call last):
  File "", line 1, in
    2 + '1'
TypeError: unsupported operand type(s) for +: 'int' and 'str'

# ValueError исключение
# ValueError (аргумент правильного типа, но некорректного значения)
int('qwerty')
Traceback (most recent call last):
  File "", line 1, in
    int('qwerty')
ValueError: invalid literal for int() with base 10: 'qwerty'

```
## Конструкция try - except

Для обработки исключений используется конструкция try - except.
```py

try:                              # (try строго 1)
    try_ suite                    # код, который может выполниться с ошибкой
except exception_group1 as var1:  # (except - 0 (если есть finally) и более)
    except_suite1                 # код, выполняемый в случае исключения 'exception_group1'
...                               # ссылка на исключение может быть записана в 'var1'
except exception_groupN as varN:
    except_suiteN                 # код, выполняемый в случае исключения 'exception_groupN'
...                               # except-блоков может быть произвольное кол-во
else:                             # (else - 0 или 1)
    else_suite                    # выполняется, если try не завершен преждевременно (например, break)
finally:                          # (finally - 0 или 1)
    finally_suite                 # код, который должен выполнится всегда (была ошибка выше или нет)

```

## Ход выполнения:
- код, который потенциально может привести к ошибке, помещается в блок try;
- в случае ошибки, код немедленно завершается и переходит в обработчик except (если он указан для соответствующего исключения);
- после поток выполнения переходит к else (если исключений не было) и finally (в любом случае).

Программный код должен быть написан с учетом того, что в любом его месте может возникнуть ошибка, для чего необходимо эффективно использовать соответствующие средства языка программирования:

- код, который потенциально может привести к ошибкам, должен быть помещен в блок try;
- блок except должен:
    - обрабатывать исключения максимально конкретно (указывать конкретные классы); стоит определять свои классы исключений, когда это это имеет смысл;
    - категорически не следует «тушить» исключения (писать пустой или бессмысленный except);
- в блоках except следует снова возбуждать исключения (raise), которые не обрабатываются явно, передавая обработку в участок кода, который должен определять дальнейшие действия программы;
- блок finally следует использовать для освобождения ресурсов (это может быть закрытие файла или сетевого соединения), независимо от того, прошла операция успешно или нет.

Обработка исключений - предпочитаемый способ в Python, а использование блоков зависит от конкретной ситуации.

### Голое исключение
```py

try:
    x = int(input("Введите целое число x (для вычисления 1/x): "))
    res = 1 / x

    print("1/{} = {:.2f}".format(x, res))
except:
    print("Произошла ошибка!")

```
На жаргоне Пайтона, это известно как голое исключение, что означает, что будут найдены вообще все исключения. Причина, по которой так делать не рекомендуется, заключается в том, что вы не узнаете, что именно за исключение вы выловите. Когда у вас возникло что-то в духе ZeroDivisionError, вы хотите выявить фрагмент, в котором происходит деление на ноль. В коде, написанном выше, вы не можете указать, что именно вам нужно выявить.

Улучшить код можно, добавив обработку исключения по классу.

## Обработка общего класса исключений Exception

вам может понадобиться способ разрешить любое произвольное исключение, а также иметь возможность отображать сообщение об ошибке или исключении.

```py

try:
    #your code
except Exception as ex:
    print(ex)

# 

try:
    x = int(input("Введите целое число x (для вычисления 1/x): "))
    res = 1 / x

    print("1/{} = {:.2f}".format(x, res))
except Exception as err:
    print("Произошла ошибка!")
    print("Тип:", type(err))
    print("Описание:", err)

```

Рекомендуемым способом обработки исключений является как можно большая конкретизация класса исключения.

## Обработка конкретных классов исключений

### ZeroDivisionError:
```py

try:
    k = 1 / 0
except ZeroDivisionError:
    k = 0

print(k)

```
В блоке try мы выполняем инструкцию, которая может породить исключение, а в блоке except мы перехватываем их. При этом перехватываются как само исключение, так и его потомки. Например, перехватывая ArithmeticError, мы также перехватываем FloatingPointError, OverflowError и ZeroDivisionError.

### ArithmeticError:
```py

try:
    k = 1 / 0
except ArithmeticError:
    k = 0

print(k)

```
Также возможна инструкция except без аргументов, которая перехватывает вообще всё (и прерывание с клавиатуры, и системный выход и т. д.). Поэтому в такой форме инструкция except практически не используется, а используется except Exception. Однако чаще всего перехватывают исключения по одному, для упрощения отладки (вдруг вы ещё другую ошибку сделаете, а except её перехватит).
```py

try:
    x = int(input("Введите целое число x (для вычисления 1/x): "))
    res = 1 / x

    print("1/{} = {:.2f}".format(x, res))
except ZeroDivisionError:
    print("На ноль делить нельзя!")
except ValueError as err:  # 'err' содержит ссылку на исключение
    print("Будьте внимательны:", err)
except (FileExistsError, FileNotFoundError):  # Исключения можно перечислять в виде кортежа
    print("Этого никогда не случится - мы не работаем с файлами")
except Exception as err:
    # Все, что не обработано выше и является потомком 'Exception',
    # будет обработано здесь
    print("Произошла ошибка!")
    print("Тип:", type(err))
    print("Описание:", err)

```

## Поймать несколько исключений в одном блоке Except
Обратите внимание, что вы можете отделить исключения от переменной запятой, которая применима в Python 2.6 / 2.7. Но вы не можете сделать это в Python 3. Поэтому вы должны использовать ключевое слово as.

```py

except (Exception1, Exception2) as e:
    pass

```

Есть много способов обработки нескольких исключений. Первый из них требует размещения всех исключений, которые могут возникать в виде кортежа.
```py

try:
    file = open('input-file', 'open mode')
except (IOError, EOFError) as e:
    print("Testing multiple exceptions. {}".format(e.args[-1]))

```
Следующий метод заключается в обработке каждого исключения в выделенном блоке Except. Вы можете добавить столько, Except блоков, сколько необходимо.
```py

try:
    file = open('input-file', 'open mode')
except EOFError as ex:
    print("Caught the EOF error.")
    raise ex
except IOError as e:
    print("Caught the I/O error.")
    raise ex

```
Используйте ключевое слово As для отлова определенных типов исключений.
С помощью <идентификатора> вы можете создать новый объект. 
```py

# создаем объект IOError и затем используем.

try:
    f = open("no-file")
except IOError as err:
    print("Error:", err)
    print("Code:", err.errno)
# Результат:

# ('Error:', IOError(2, 'No such file or directory'))
# ('Code:', 2)

```

Существует возможность передать подробную информацию о произошедшем исключении в код внутри блока except.
```py

print("start")
try:
   val = int(input("input number: "))
   tmp = 10 / val
   print(tmp)
except ValueError as ve:
   print("ValueError! {0}".format(ve))
except ZeroDivisionError as zde:
   print("ZeroDivisionError! {0}".format(zde))
except Exception as ex:
   print("Error! {0}".format(ex))
print("stop")

```

## Finally блок
Если у вас есть код, который вы хотите запустить во всех ситуациях, напишите его в блоке finally. Python всегда будет выполнять инструкции, добавленные в блоке finally. Это наиболее распространенный способ выполнения задач по очистке. Вы также можете убедиться, что очистка прошла.

Ошибка поймана в блоке try. После того, как код в блоке except будет выполнен, инструкции в блоке finally будут выполнены.

Обратите внимание, что блок finally будет ВСЕГДА работать, даже если вы вернулись раньше него.
```py


try:
    x = 1 / 0
except:
    print("Error occurred")
finally:
    print("The [finally clause] is hit")

```
## Else блок
Используйте предложение else сразу после блока try-except. Предложение else будет получено, только если не сгенерировано исключение. Оператор else всегда должен предшествовать блокам except.

В блоки else вы можете добавить код, который хотите запустить, если ошибок не было.

В примере ниже, вы можете увидеть бесконечный цикл while. Код запрашивает ввод данных пользователем, а затем анализирует его, используя встроенную функцию int(). Если пользователь вводит значение ноль, тогда блоком исключений будет достигнут успех. В противном случае код будет проходить через блок else.
```py

while True:
    x = int(input())

    try:
        result = 1 / x
    except:
        print("Error case")
        exit(0)
    else:
        print("Pass case")
        exit(1)


```
Finally выполняет блок инструкций в любом случае, было ли исключение, или нет (применима, когда нужно непременно что-то сделать, к примеру, закрыть файл). 
Инструкция else выполняется в том случае, если исключения не было.
```py

f = open('1.txt')
ints = []
try:
    for line in f:
        ints.append(int(line))
except ValueError:
    print('Это не число. Выходим.')
except Exception:
    print('Это что ещё такое?')
else:
    print('Всё хорошо.')
finally:
    f.close()
    print('Я закрыл файл.')
# Именно в таком порядке: try, группа except, затем else, и только потом finally.

```

Также исключение может возникнуть в блоке except, else или finally, и тогда им нужен собственный обработчик. Модифицируем немного предыдущую программу и специально сгенерируем исключение в теле except:
```py

try:
    n = input('Введите целое число: ')
    n = int(n)
except ValueError:
    print("Вы что-то попутали с вводом")
    3 / 0
except ZeroDivisionError:
    print("Деление на ноль")
else:
    print("Все нормально. Вы ввели число", n)
finally:
    print("Конец программы")

```
Исключение, генерируемое выражением 3 / 0 не будет обработано веткой except ZeroDivisionError. Эта ветка обрабатывает только исключения, возникающие в блоке try, к которому она сама относится.

Решение может быть таким:

```py

except ValueError:
    print("Вы что-то попутали с вводом")
    try:
       3 / 0
    except ZeroDivisionError:
        print("Деление на ноль")

```

## Возбуждение исключений (raise)
Исключения являются не только механизмом обработки ошибок, но и удобным средством управления потоком выполнения. Так, необходимое исключение можно возбудить вручную, когда это необходимо, используя конструкцию raise.
```py

raise
raise exception(args)  # явное указание класса возбуждаемого исключения

# или
raise                  # 1) повторное возбуждение активного исключения (re-raise)
                       #    внутри блока except
                       # 2) 'TypeError' по умолчанию
```
Возбуждаемое исключение может быть как встроенным (если соответствует по смыслу), так и пользовательским (создаваемым самостоятельно).

## Повторный проброс исключений в Python

Возникшие когда-либо исключения продолжают перемещаться к вызывающим методам, пока не будут обработаны. Хотя вы можете добавить исключающее предложение, которое может просто вызывать raise без каких-либо аргументов. Это приведет к пересмотру исключения.

```py

try:
    # Преднамеренно бросить исключение.
    raise Exception('I learn Python!')
except:
    print("Entered in except.")
    # Возобновить исключение.
    raise
# Вывод:

# Entered in except.
# Traceback (most recent call last):
#   File "python", line 3, in 
# Exception: I learn Python!

```
## Обработка нескольких исключений одним блоком Except
использовать исключение без упоминания какого-либо атрибута исключения.
```py
try:
    file = open('input-file', 'open mode')
except:
    raise

```
Этот метод может быть полезен, если вы не имеете ни малейшего представления об исключении, которое может выдать ваша программа.

## Использование raise для управления потоком выполнения
```py

MIN = 1
MAX = 10

try:
    x = int(input("Введите целое число от {} до {}: ".format(MIN, MAX)))

    if not MIN <= x <= MAX:
        # Возбудив исключение, его можно будет обработать в except
        # вместе с другими похожими исключениями
        raise ValueError("Число лежит вне интервала [{}; {}]!".format(MIN, MAX))

    print("Спасибо!")
except ValueError as err:  # 'err' содержит ссылку на исключение
    print("Будьте внимательны:", err)

```

## Особенности обработки исключений внутри функций

Обработка исключений аналогично производится и внутри функций, однако, необходимо писать код так, чтобы вызывающий код знал о случившемся, если это влияет на его дальнейшую работу.

Основное правило - обработка исключений внутри возможна и нужна, однако вызывающий код должен также знать о случившемся, если влияет на дальнейшую работу

```py

def get_1_x(x):
    """Вернуть 1/x.

    Функция не обрабатывает исключения - ответственность на вызывающем коде.
    """
    return 1/x


def get_2_x(x):
    """Вернуть 2/x.

    Функция обрабатывает исключения, "затушив" ошибку - вызывающий код
    не будет знать, сработала функция правильно или нет.

    Данный способ использовать не рекомендуется!
    """
    try:
        return 2/x
    except Exception as e:
        print("Внутри произошла ошибка...", e)


def get_3_x(x):
    """Вернуть 3/x.

    Функция не только обрабатывает исключения, но перевозбуждает его:
    в результате вызывающий так же получает возникшее исключение.

    Внутренняя обработка исключений может быть полезна, если в целом результат
    функции не связан с внутренней ошибкой.
    """
    try:
        return 3/x
    except Exception as e:
        print("Внутри произошла ошибка...", e)
        raise

funcs = (get_1_x, get_2_x, get_3_x)



# Вызываем каждую функцию с "ошибочным" параметром
for func in funcs:
    try:
        print("-" * 50)
        print("Запущена функция:", func.__name__)
        print(func(0))
    except Exception as e:
        print("Произошла ошибка: {}.".format(e))
```
Избегайте генерирования общих исключений, потому что если вы это сделаете, то должны быть перехвачены и все другие более конкретные исключения. Следовательно, лучшая практика заключается в том, чтобы поднять наиболее конкретное исключение, близкое к вашей проблеме.

```py

# Плохой пример:

def bad_exception():
    try:
        raise ValueError('Intentional - do not want this to get caught')
        raise Exception('Exception to be handled')
    except Exception as error:
        print('Inside the except block: ' + repr(error))
        
bad_exception()

# Пример получше:
# Здесь мы приводим конкретный тип исключения, а не общий тип. И мы также используем опцию args для вывода неверных аргументов, если они есть. Давайте посмотрим на приведенный ниже пример.

try:
    raise ValueError('Testing exceptions: The input is in incorrect order', 'one', 'two', 'four') 
except ValueError as err:
    print(err.args)

```
## Утверждения (assert)
Еще один способ, используемый для борьбы с ошибками - использование утверждений - специальных конструкций, выполняющих проверку произвольного условия на истинность.

В Python утверждения поддерживаются оператором assert.
```py
assert
assert boolean_expression[, optional_expression]

# boolean_expression: логическое выражение для проверки
# optional_expression: необязательное сообщение (строка)
Если boolean_expression возвращает False, возбуждается исключение AssertionError с сообщением optional_expression (если задано).

```
## Использование утверждений в Python

```py

# Использование оператора assert поможет отследить неверно реализованную функцию

def add_to_list(x, lst=[]):
    # Использование assert здесь оправдано - список всегда
    # подразумевается пустым
    assert len(lst) == 0, "Список должен быть пуст!"

    lst.append(x)
    return lst

print(add_to_list(1))
print(add_to_list(2))

```
В отличие от исключений утверждения являются отладочным инструментом и могут быть отключены при компиляции/интерпретации программы

## Как пропустить ошибки и продолжить выполнение
В идеале, вы не должны этого делать. Но если вы все еще хотите это сделать, следуйте приведенному ниже коду, чтобы проверить правильный подход.
```py

try:
    assert False
except AssertionError:
    pass
print('Welcome to Prometheus!!!')

```
## Примеры использования исключения и утверждений

```py

# Исключения и утверждения могут проверять параметры функции, выступая в т.ч. более строгим вариантом документации

def fact(x):
    """Вернуть факториал 'x'.

    Не передавайте числа больше 15 во избежание переполнения памяти.
    """
    if x <= 1:
        return 1
    else:
        return x * fact(x-1)

def fact_save_1(x):
    assert x <= 15, \
        "Не передавайте числа больше 15 во избежание переполнения памяти"

    return fact(x)


def fact_save_2(x):
    if not x <= 15:
        raise ValueError("Не передавайте числа больше 15 во избежание "
                         "переполнения памяти")

    return fact(x)


print("{:>3} {:>20} {:>20}".format(*("x", "fact()", "fact_save()")))
for x in (5, 20):
    print("{:3}".format(x), end=" ")
    print("{:20}".format(fact(x)), end=" ")
    # print("{:20}".format(fact_save_1(x)))
    print("{:20}".format(fact_save_2(x)))

# Использование оператора assert для проверки входных и выходных данных

def make_call(accounts, account_id, mins, costs_per_min):
    """Списать со счета 'account' на 'value' баллов в случае звонка.

    Параметры:
        - accounts (dict): словарь со всеми счетами абонентов;
        - account_id (int): идентификатор абонента в словаре 'accounts';
        - mins (int): количество минут разговора;
        - costs_per_min (int): стоимость минуты разговора.
    """

    def get_costs(mins, costs_per_min):
        """Вернуть стоимость звонка.

        Параметры:
            - mins (int): количество минут разговора;
            - costs_per_min (int): стоимость минуты разговора.
        """
        return -mins * costs_per_min

    # Проверка типов
    assert isinstance(mins, int), "Параметр 'mins' имеет неверный тип!"
    assert isinstance(costs_per_min, (int, float)),\
        "Параметр 'costs_per_min' имеет неверный тип!"

    # Проверка значений
    assert mins > 0, "Параметр 'mins' должен быть > 0"
    assert costs_per_min >= 0, "Параметр 'costs' должен быть >= 0"

    # Расчет (стоимость звонка не должна быть меньше 0)
    costs_total = get_costs(mins, costs_per_min)
    assert costs_total >= 0,\
        "Расчет стоимости звонка был осуществлен неверно!"
    accounts[account_id] -= costs_total


# Словарь ID=Баланс
accounts = {"John Doe": 100}
print(accounts)

try:
    make_call(accounts, "John Doe", mins=4, costs_per_min=2)
except Exception as e:
    print("Во время списывания стоимости звонка произошла ошибка:", e)

print(accounts)


# Совместное использование исключений и утверждений

weekday_names = {
    1: "Понедельник",
    2: "Вторник",
    3: "Среда",
    4: "Четверг",
    5: "Пятница",
    6: "Суббота",
    7: "Воскресенье"
}

def weekday_name(weekday):
    """Вернуть название дня недели. Нумерация с 1.

    Параметры:
        weekday (int): номер дня недели.

    Исключения:
        - TypeError: 'weekday' не int;
        - ValueError: 'weekday' не число от 1 до 7.

    Результат:
        str: название дня недели.
    """
    # "Невозможная" ситуация - словарь 'weekday_names' может быть
    # "испорчен" - проверяется с помощью assert.
    assert weekday_names is not None and isinstance(weekday_names, dict), \
        "Внутренняя ошибка программы. Обратитесь в разрабочику."

    # Параметры функции проверяются с помощью исключений
    if not isinstance(weekday, int):
        raise TypeError("Параметр 'weekday' должен быть типа 'int'.")
    if weekday not in weekday_names:
        raise ValueError("Параметр 'weekday' должен быть целым числом "
                         "от 1 до 7.")

    return weekday_names[weekday]

# Блок try используется в любом случае т.к. может возникнуть ошибка
# независимо от того, используется пользовательский ввод,
# чтение данных из какого-либо источника или просто вызов функции

while True:
    try:
        weekday = int(input("Введите номер дня недели (1-7): "))

        # if not 1 <= weekday <= 7:
        #     raise ValueError("Номер дня недели должен быть целым числом "
        #                      "от 1 до 7.")

        # Раскомментируйте код ниже, чтобы получить срабатывание assert
        # weekday_names = None

        print("Это -", weekday_name(weekday))

        break
    except TypeError as err:
        print("Проверьте, что введено целое число.")
    except ValueError as err:
        print("Проверьте, что введено целое число, и оно "
              "находится в допустимых границах.")
    except Exception as err:
        print("Ошибка при определении названия дня недели.")
        print(err)  # Запись в лог информации об ошибке

```


## Пользовательские исключения (User-defined Exceptions) в Python
В Python можно создавать собственные исключения. Такая практика позволяет увеличить гибкость процесса обработки ошибок в рамках той предметной области, для которой написана ваша программа.

Для реализации собственного типа исключения необходимо создать класс, являющийся наследником от одного из классов исключений.
```py

class NegValException(Exception):
   pass

try:
   val = int(input("input positive number: "))
   if val < 0:
       raise NegValException("Neg val: " + str(val))
   print(val + 10)
except NegValException as e:
  print(e)

```