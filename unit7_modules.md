# Модули и пакеты

Модули и пакеты значительно упрощают работу программиста. Классы, объекты, функции и константы, которыми приходится часто пользоваться можно упаковать в модуль, и, в дальнейшем, загружать его в свои программы при необходимости. Пакеты позволяют формировать пространства имен для работы с модулями.

Модули предназначены для того, чтобы в них хранить часто используемые функции, классы, константы и т.п. Можно условно разделить модули и программы: программы предназначены для непосредственного запуска, а модули для импортирования их в другие программы. Стоит заметить, что модули могут быть написаны не только на языке Python, но и на других языках (например C).

Модуль — это файл, содержащий определения и операторы Python. Именем файла является имя модуля с добавленным суффиксом .py. 

# Импорт модуля
Модуль можно импортировать в другую программу, чтобы использовать функции из него. Точно так же мы используем стандартную библиотеку Python. 

Самый простой способ импортировать модуль в Python это воспользоваться конструкцией:
```py
import имя_модуля
```

## Модули стандартной библиотеки.
```py
import sys

print('Аргументы командной строки:')
for i in sys.argv:
    print(i)

print('\n\nПеременная PYTHONPATH содержит', sys.path, '\n')

```

В начале мы импортируем модуль sys командой import. Модуль sys содержит функции, относящиеся к интерпретатору Python и его среде, т.е. к системе (system).

Когда Python выполняет команду import sys, он ищет модуль sys. В данном случае это один из встроенных модулей, и Python знает, где его искать.

Если бы это был не скомпилированный модуль, т.е. модуль, написанный на Python, тогда интерпретатор Python искал бы его в каталогах, перечисленных в переменной sys.path. Если модуль найден, выполняются команды в теле модуля, и он становится доступным. инициализация происходит только при первом импорте модуля.

## Путь поиска модулей

Если импортируется модуль с именем spam, интерпретатор ищет файл с именем spam.py в текущем каталоге, а затем в каталогах, указанных в переменной окружения PYTHONPATH. У неё такой же синтаксис, как и у переменной шелла PATH, которая, в свою очередь, является перечислением каталогов. Когда переменная PYTHONPATH не установлена, или файл не найден в описанных в ней местах, поиск продолжается по пути по умолчанию, зависящему от указанного при установке; на Unix это обычно .:/usr/local/lib/python.

Поиск модулей производится в списке каталогов в переменной sys.path, которая содержит: каталог, в котором находится сценарий (или текущий каталог), PYTHONPATH и умолчанием для каталога, указанного при установке. Это позволяет программам на Python изменять или подменять путь поиска модулей. Поскольку каталог, содержащий запускаемый сценарий, также находится в пути поиска, важно, чтобы в нем не было сценариев с именем стандартного модуля. Иначе, когда этот модуль будет импортироваться, Python будет пытаться загрузить в виде модуля сам сценарий, что в большинстве случаев вызовет ошибку.

## Расширение пути загрузки модуля
Есть несколько способов сказать интерпретатору Python, где искать модули, кроме используемых по умолчанию, которыми является локальный каталог и встроенные модули. Вы можете использовать переменную окружения PYTHONPATH чтобы указать дополнительные каталоги для поиска модулей, например так:

PYTHONPATH=/foo python game.py
Настоящим будет запущен game.py, что позволит скрипту загрузить модули из каталога foo, а также из локального каталога.

Другим методом является функция sys.path.append. Вы можете выполнить его до запуска команды import:
```py
sys.path.append("/foo")
```
Это добавит каталог foo в список путей для поиска модулей.

## Доступ к переменной argv
Доступ к переменной argv в модуле sys предоставляется при помощи точки, т.е. sys.argv. Это явно показывает, что это имя является частью модуля sys. Ещё одним преимуществом такого обозначения является то, что имя не конфликтует с именем переменной argv, которая может использоваться в вашей программе.

Переменная sys.argv является списком строк. Она содержит список аргументов командной строки, т.е. аргументов, переданных программе из командной строки.

В нашем примере, когда мы запускаем “python using_sys.py we are arguments”, мы запускаем модуль using_sys.py командой python, а всё, что следует далее – аргументы, передаваемые программе. Python сохраняет аргументы командной строки в переменной sys.argv для дальнейшего использования.

Помните, что имя запускаемого сценария всегда является первым аргументом в списке sys.argv. Так что в приведённом примере 'using_sys.py' будет элементом sys.argv[0], 'we' – sys.argv[1], 'are' – sys.argv[2], а 'arguments' – sys.argv[3]. Помните, что в Python нумерация начинается с 0, а не с 1.

sys.path содержит список имён каталогов, откуда импортируются модули. Заметьте, что первая строка в sys.path пуста; эта пустая строка показывает, что текущая директория также является частью sys.path, которая совпадает со значением переменной окружения PYTHONPATH. Это означает, что модули, расположенные в текущем каталоге, можно импортировать напрямую. В противном случае придётся поместить свой модуль в один из каталогов, перечисленных в sys.path.

Помните, что текущий каталог – это каталог, в котором была запущена программа. Выполните “import os; print(os.getcwd())”, чтобы узнать текущий каталог программы.

## Импорт модуля math
Импорт и использование модуля math, который содержит математические функции, будет выглядеть вот так.
```py

mport math
math.factorial(5) # 120

```
За один раз можно импортировать сразу несколько модулей, для этого их нужно перечислить через запятую после слова import:
```py

import имя_модуля1, имя_модуля2

import math, datetime
math.cos(math.pi/4) # 0.707106781186547

datetime.date(2021, 3, 21)
datetime.date(2021, 3, 21)

```
## Импортируемому объекту можно задать псевдоним
Если вы хотите задать псевдоним для модуля в вашей программе, можно воспользоваться таким синтаксисом:
```py

import имя_модуля as новое_имя

import math as m
m.sin(m.pi/3) # 0.866025403784438


from имя_модуля import имя_объекта as псевдоним_объекта

from math import factorial as f
f(4) # 24
```
Используя любой из вышеперечисленных подходов, при вызове функции из импортированного модуля, вам всегда придется указывать имя модуля (или псевдоним). Для того, чтобы этого избежать делайте импорт через конструкцию from … import…
```py

from имя_модуля import имя_объекта

from math import cos
cos(3.14) # 0.999998731727539

```
При этом импортируется только конкретный объект (в примере: функция cos), остальные функции недоступны, даже если при их вызове указать имя модуля.
```py

from math import cos
cos(3.14) # -0.999998731727539
sin(3.14)
# Traceback (most recent call last):
#   File "<pyshell#2>", line 1, in <module>
#     sin(3.14)
# NameError: name 'sin' is not defined
math.sin(3.14)
# Traceback (most recent call last):
#   File "<pyshell#3>", line 1, in <module>
#     math.sin(3.14)
# NameError: name 'math' is not defined

```
Для имортирования нескольких функций из модуля, можно перечислить их имена через запятую.
```py

from имя_модуля import имя_объекта1, имя_объекта2

from math import cos, sin, pi
cos(pi/3) # 0.500000000000000
sin(pi/3) # 0.866025403784438

```
## Импорт всех объектов из модуля

Если необходимо импортировать все фукнции, классы и т.п. из модуля, то воспользуйтесь следующей формой оператора from … import …
```py

from имя_модуля import *

from math import *
cos(pi/2) # 6.123233995736766e-17
sin(pi/4) # 0.707106781186547
factorial(6) # 720

```
Мы также можем использовать команду import * для импорта всех объектов из определенного модуля

Для импорта всех имён, использующихся в модуле sys, можно выполнить команду: from sys import *

В общем случае следует избегать использования этого оператора и использовать вместо этого оператор import, чтобы предотвратить конфликты имён и не затруднять чтение программы.
```py

from math import *
n = int(input("Введите диапазон:-  "))
p = [2, 3]
count = 2
a = 5
while (count < n):
    b=0
    for i in range(2,a):
        if ( i <= sqrt(a)):
            if (a % i == 0):
                print(a,"непростое")
                b = 1
            else:
                pass

    if (b != 1):
        print(a,"простое")
        p = p + [a]
    count = count + 1
    a = a + 2
print(p)

```

## Создание собственных модулей

Создать собственный модуль очень легко. каждая программа на Python также является и модулем. Mодули в Python - это просто файлы Python с расширением .py. Имя модуля будет именем файла. Модуль Python может иметь набор функций, классов или переменных, определенных и реализованных. 
```py

def sayhi():
    print('Привет! Это говорит мой модуль.')

__version__ = '0.1'

# Конец модуля mymodule.py

```
модуль должен находиться либо в том же каталоге, что и программа, в которую мы импортируем его, либо в одном из каталогов, указанных в sys.path.
```py
import mymodule

mymodule.sayhi()
print ('Версия', mymodule.__version__)

```

Python повсеместно использует одно и то же обозначение точкой, придавая ему таким образом характерный “Python-овый” вид и не вынуждая нас изучать всё новые и новые способы делать что-либо.

Версия, использующая синтаксис from..import:
```py

from mymodule import sayhi, __version__

sayhi()
print('Версия', __version__)

```

если в модуле, импортирующем данный модуль, уже было объявлено имя __version__, возникнет конфликт. Это весьма вероятно, так как объявлять версию любого модуля при помощи этого имени – общепринятая практика. Поэтому всегда рекомендуется отдавать предпочтение оператору import.

Вы могли бы также использовать:

from mymodule import *

Это импортирует все публичные имена, такие как sayhi, но не импортирует __version__, потому что оно начинается с двойного подчёркивания

## Модуль вычисления чисел Фибоначчи
используя текстовый редактор, создайте в текущем каталоге файл с именем fibo.py со следующим содержимым:
```py

"""Модуль вычисления чисел Фибоначчи"""
 
def fib(n):    # вывести числа Фибоначчи вплоть до n
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a+b
    print()
 
def fib2(n): # вернуть числа Фибоначчи вплоть до n
    result = []
    a, b = 0, 1
    while b < n:
        result.append(b)
        a, b = b, a+b
    return result

```
Теперь можно войти в интерпретатор Python и импортировать этот модуль следующей командой:
```py
import fibo

```
Это действие не переводит имена определённых в модуле функций в текущую таблицу символов, а лишь имя модуля fibo. Используя имя модуля, вы можете получить доступ к функциям:
```py
fibo.fib(1000) # 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
fibo.fib2(100) # [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
fibo.__name__ # 'fibo'

```
Если вы собираетесь использовать функцию часто, можно присвоить её локальному имени:
```py
fib = fibo.fib
fib(500) # 1 1 2 3 5 8 13 21 34 55 89 144 233 377

```

Скрипт app.py может выглядеть примерно так:

```py
# app.py
# Модули импортируются из других модулей с помощью команды import. 
# import the fibo module
import fibo

def main():
    
    fibo.fib(100)

    result = fibo.fib2(1000)
    print(result)

# this means that if this script is executed, then 
# main() will be executed
if __name__ == '__main__':
    main()

```
Когда директива import fibo будет запущена, интерпретатор Python будет искать файл в каталоге, из которого был выполнен скрипт app.py. Если он найдет его, то импортирует, если нет, продолжит искать встроенные модули.

## Инициализация модуля

Помимо определений функций модуль может содержать исполняемые операторы. Назначение этих операторов — инициализация модуля: они выполняются при первом импортировании модуля где-либо.

Каждый модуль имеет свою собственную таблицу символов, которая используется в качестве глобальной всеми определёнными в модуле функциями. Таким образом, автор модуля может использовать глобальные символы в модуле, не опасаясь неожиданных совпадений с глобальными переменными пользователя. С другой стороны, если вы знаете, что делаете, можно сослаться на глобальные переменные модуля, пользуясь той же нотацией, которая применялась для ссылок на его функции: <имя_модуля>.<имя_элемента>.

Модули могут импортировать другие модули. Не требуется указывать все операторы import в начале модуля (или сценария), но обычно так и делается. Имена из импортированного модуля добавляются в глобальную таблицу символов модуля его импортирующего.

## Импорт объектов модуля в текущее пространство имен
вариант оператора import, который переносит имена из модуля прямо в таблицу символов импортирующего модуля, используя команду from:
```py
from fibo import fib, fib2
fib(500) #1 1 2 3 5 8 13 21 34 55 89 144 233 377

```
При этом имя самого модуля, из которого переносятся имена элементов, не добавляется в локальную таблицу символов (так, в этом примере, имя fibo не определено)
```py
  # способ импортировать все имена, которые определяет данный модуль:
  from fibo import *
```
Импортируются все имена, кроме тех, которые начинаются на подчёркивание _. В большинстве случаев программисты на Python не используют эту возможность, поскольку она внедряет в интерпретатор целый набор новых неизвестных имён и может скрыть некоторые объекты, которые вы уже определили.

Для повышения эффективности, каждый модуль импортируется лишь единожды за сеанс работы с интерпретатором. Поэтому, если вы изменили ваши модули, вам придётся перезапустить интерпретатор. Или, если вам нужно перезагрузить конкретный модуль, можно использовать imp.reload() таким образом: 
```py
import imp; imp.reload(<имя_модуля>)
```

## Выполнение модулей
```py
if __name__ == '__main__':
    print('Эта программа запущена сама по себе.')
else:
    print('Меня импортировали в другой модуль.')
```

## Имя модуля – __name__

У каждого модуля есть имя, и команды в модуле могут узнать имя их модуля. Это полезно, когда нужно знать, запущен ли модуль как самостоятельная программа или импортирован. Как уже упоминалось выше, когда модуль импортируется впервые, содержащийся в нём код исполняется. Мы можем воспользоваться этим для того, чтобы заставить модуль вести себя по-разному в зависимости от того, используется ли он сам по себе или импортируется в другую программа. Этого можно достичь с применением атрибута модуля под названием __name__.

Когда вы запускаете модуль Python в виде
```py
python fibo.py <параметры>
```
то код в этом модуле будет исполнен в момент его импортирования, но значением __name__ будет строка "__main__". Это значит, что добавляя следующий код в конец сценария:
```py
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))

```
вы можете сделать возможным запуск файла и в качестве сценария, и в качестве импортируемого модуля. Это возможно, поскольку разбирающий командную строку код выполняется только при исполнении модуля как основного (main) файла:
```py
$ python fibo.py 50
```
Если модуль импортируется, код не будет выполнен:
```py
import fibo
```
Такой приём часто используется, чтобы предоставить удобный пользовательский интерфейс к модулю или для тестирования (выполнение модуля в качестве сценария запускает набор тестов).

## Скомпилированные файлы Python

При импорте модуля появляется файл .pyc, который представляет собой скомпилированный файл Python.

Интерпретатор Python применяет один важный приём для ускорения запуска программы: если в каталоге, где располагается файл с некоторым модулем fibo.py, находится также файл fibo.pyc, предполагается, что это уже скомпилированная в байт-код (byte-compiled) версия модуля. В файле fibo.pyc зафиксировано время изменения файла fibo.py версии, использовавшейся для создания fibo.pyc. Если версии не совпадают — файл .pyc игнорируется.

Каждый раз, когда fibo.py успешно компилируется, предпринимается попытка записать скомпилированную версию в fibo.pyc. Не считается ошибкой, если попытка неудачна: если по какой-либо причине файл не записан полностью, результирующий файл fibo.pyc будет считаться некорректным и по этой причине в дальнейшем игнорироваться. Содержимое файла fibo.pyc платформо-независимо, благодаря чему каталог модулей Python может использоваться параллельно машинами с различной архитектурой.

Когда интерпретатор Python запускается с флагом -O, в файлах .pyo сохраняется сгенерированный оптимизированный код. На данный момент оптимизатор помогает не сильно — он лишь удаляет операторы assert. В случае использования -O оптимизируется весь байт-код (bytecode); файлы .pyc игнорируются, а файлы .py компилируются в оптимизированный байт-код.

Передача двух флагов -O интерпретатору Python (-OO) принуждает компилятор байт-кода выполнять оптимизации, в редких случаях результат выполнения которых оказывается некачественно функционирующей программой. На данный момент из байт-кода удаляются только строки __doc__, в результате получаются более компактные файлы .pyo. Поскольку некоторые программы могут рассчитывать на их (строк) доступность, следует использовать эту возможность только в том случае, если вы знаете что делаете.

Программа сама по себе не работает хоть сколь-нибудь быстрее, будучи прочитанной из файла .pyc или .pyo, чем если бы она была прочитана из файла .py. Единственный процесс, оказывающийся более быстрым при использовании файлов .pyc или .pyo — это скорость их подгрузки.

Если сценарий запущен из командной строки, его байт-код никогда не будет записан в файл .pyc или .pyo. Таким образом, время запуска сценария может быть уменьшено за счёт перемещения большей части его кода в модули или использования небольшого загрузочного сценария, импортирующего этот модуль. Кроме того, можно указывать файл .pyc или .pyo прямо в командной строке.

Можно иметь в наличии файл с именем fibo.pyc (или fibo.pyo, когда используется -O), не имея файла fibo.py для того же модуля. Таким образом можно распространять библиотеки кода Python в том виде, из которого трудно восстановить исходный код.

Модуль compileall может создать файлы .pyc (или файлы .pyo, когда используется -O) для всех модулей в каталоге.

## Пакеты в Python

Пакеты — способ структурирования пространств имён (namespaces) модулей Python за счёт использования имён модулей, разделённых точками (dotted module names). Например, имя модуля A.B означает — подмодуль с именем B в пакете с именем A. Также как использование модулей позволяет авторам различных модулей не заботиться о пересекающихся именах среди глобальных переменных, использование именования через точку позволяет авторам многомодульных пакетов (таких как NumPy или Python Imaging Library) не заботиться о конфликтах имён модулей.

Пакеты – это просто каталоги с модулями и специальным файлом __init__.py, который показывает Python, что этот каталог особый, так как содержит модули Python:
```

| - <некоторый каталог из sys.path>/
| |---- functions/
|      |---- __init__.py
|      |---- algo/
|      |    |---- __init__.py
|      |    |---- fany/
|      |         |---- __init__.py
|      |         |---- foo.py
|      |         |---- fibo.py
|      |---- tiger/
|           |---- __init__.py
|           |---- fany/
|                |---- __init__.py
|                |---- bar.py
|                |---- fibo2.py

```
Пакеты – это удобный способ иерархически организовать модули. Такое часто встречается в стандартной библиотеке.

Точно так же, как функции являются многократно используемыми фрагментами программ, модули являются многократно используемыми программами. Пакеты – это способ иерархической организации модулей. Стандартная библиотека Python является примером такого набора пакетов и модулей.

При импорте пакета Python ищет подкаталог пакета в каталогах, перечисленных в sys.path.

Файлы __init__.py необходимы для того, чтобы Python трактовал эти каталоги как содержащие пакеты. Это сделано во избежание нечаянного сокрытия правомерных модулей, встречающихся в дальнейшем по пути поиска, каталогами с часто используемыми именами, таким как "string". В наипростейшем случае файл __init__.py может быть пустым, но в более сложных может содержать код инициализации пакета или устанавливать значение описанной ниже переменной __all__.

Пользователи пакета могут импортировать из него конкретные модули, например:
```py

import functions.algo.fany.fibo

```
Другой способ импортирования подмодуля:
```py

from functions.algo.fany import fibo

```
Так тоже подгружается подмодуль fibo, но теперь он доступен без префикса пакета, поэтому может использоваться следующим образом:
```py

fibo.fibo(22)

```
И еще один вариант — прямое импортирование желаемой функции или переменной:
```py

from functions.algo.fany.fibo import fibo

```
таким образом подгружается подмодуль fibo, но теперь его функция fibo() может быть вызвана непосредственно:
```py

fibo(22)

```
при использовании выражения from пакет import элемент, элементом может быть подмодуль (или подпакет) пакета или любое другое имя, определённое в пакете - например, функция, класс или переменная. Оператор import сначала проверяет, определён ли элемент в пакете; если нет — он трактует его как модуль и пытается загрузить. Если не удается его найти, порождается исключение ImportError.

Напротив, при использовании синтаксиса в стиле import элемент.подэлемент.подэлемент, все элементы кроме последнего должны быть пакетами; последний элемент может быть модулем или пакетом, но не может быть классом, функцией или переменной, определёнными в предыдущем элементе.

## Импорт * из пакета

Что происходит, когда пользователь пишет from sound.effects import * ? В идеале, мы бы надеялись, что таким образом код выходит в файловую систему и находит какие подмодули существуют в пакете, импортируя их все. К сожалению, такой метод не очень хорошо работает на платформах Windows, поскольку у файловой системы не всегда есть корректная информация о регистре имён файлов. На этих платформах нет гарантированного способа узнать, нужно ли импортировать файл ECHO.PY в качестве модуля echo, Echo или ECHO. (Например, у Windows 95 есть назойливая привычка показывать имена всех файлов с заглавной буквы.) Ограничение DOS на имя файла в формате 8+3 добавляет забавную проблему, связанную с длинными именами модулей.

Единственный выход для автора пакета — предоставить его подробное содержание. Оператор import использует следующее соглашение: если в коде файла __init__.py текущего пакета определён список __all__, то он полагается списком имён модулей, которые нужно импортировать в случае from пакет import *. На совести автора поддержка этого списка в соответствующем состоянии в каждой новой версии пакета. Впрочем, авторы пакета могут его не поддерживать вообще, если не видят смысла в импортировании * из их пакета. Например, файл functions/algo/fany/__init__.py может содержать следующий код:
```py

__all__ = ["foo", "bar", "baz"]

```
Это будет значить, что выражение 
```py
from packages.functions.tiger.fany import *
```
импортирует три именованных подмодуля из пакета functions.

Если список __all__ не определён, оператор 
```py
from packages.functions.tiger.fany import *
```
не импортирует все подмодули пакета functions.algo.fany в текущее пространство имён: он лишь убеждается, что импортирован пакет functions.algo.fany (возможно, выполняя код инициализации из __init__.py), а затем импортирует все определённые в пакете имена. В этот список попадают любые имена, определённые (и загруженные явно подмодулями) в __init__.py. В него также попадают все явно загруженные предшествующими операторами import подмодули. 

В общем случае импортирование * из модуля не приветствуется, поскольку в результате часто получается плохо-читаемый код. Однако, вполне нормально использовать его в интерактивных сессиях, чтобы меньше печатать, а определённые модули разработаны для экспорта только тех имён, которые следуют определённым шаблонам.

В использовании from пакет import определённый_подмодуль нет ничего плохого. На самом деле — это рекомендованная запись, до тех пор пока при импортировании модуля не нужно использовать подмодулей с одинаковым именем из разных пакетов.

## Ссылки внутри пакета

Когда пакеты структурированы в подпакеты, для того, чтобы сослаться на пакеты-потомки вы можете использовать абсолютное импортирование (absolute imports). Например, если модуль sound.filters.vocoder нуждается в модуле echo из пакета sound.effects, он должен использовать from sound.effects import echo.

Вы можете также использовать относительное импортирование (relative imports), применяя следующую форму оператора import: from модуль import имя . При таком способе импортирования для описания текущего и родительского пакетов используется символ точки. Например, для модуля surround вы можете написать:
```py

from . import echo
from .. import formats
from ..filters import equalizer

```
Относительное импортирование основано на имени текущего модуля. Поскольку имя главного модуля всегда „__main__“, модули, предназначенные для использования в качестве главных модулей приложения на Python, должны всегда использовать абсолютное импортирование (absolute imports).

Файлы __init__.py могут содержать программный код на языке Python, как любые другие файлы модулей. Отчасти они являются объявлениями для интерпретатора и могут вообще ничего не содержать. Эти файлы, будучи объявлениями, предотвращают неумышленное сокрытие в каталогах с совпадающими именами истинно требуемых модулей, если они отображаются позже в списке путей поиска модулей. Без этого защитного механизма интерпретатор мог бы выбирать  каталоги,  которые  не  имеют  никакого  отношения  к  вашему  программному коду, только лишь потому, что в пути поиска они появляются ранее.
В общем случае файл __init__.py предназначен для выполнения действий по инициализации пакета, создания пространства имен для каталога и реализации поведения инструкций from * (то есть from ... import *), когда они используются для импортирования каталогов:


## Инициализация пакета
Когда интерпретатор Python импортрирует каталог в первый раз он автоматически запускает программный код файла __init__.py этого каталога. По этой причине обычно в эти файлы помещается программный код, выполняющий действия по инициализации, необходимые для файлов в пакете.
Например, этот файл инициализации в пакете может использоваться для создания файлов с данными, открытия соединения с базой данных и так далее. Обычно файлы __init__.py не предназначены для непосредственного выполнения – они запускаются автоматически, когда выполняется первое обращение к пакету.

## Инициализация пространства имен модуля
При импортировании пакетов пути к каталогам в вашем сценарии после завершения операции импортирования превращаются в настоящие иерархии вложенных объектов. Например, в предыдущем примере после завершения операции импортирования можно будет использовать выражение dir1.dir2, которое возвращает объект модуля, чье пространство имен содержит все имена, определяемые файлом __init__.py из каталога dir2. Такие файлы создают пространства имен для объектов модулей, соответствующих каталогам, в которых отсутствуют настоящие файлы модулей.

## Поведение инструкции from *
В качестве дополнительной особенности, в файлах __init__.py можно использовать списки __all__, чтобы определить, что будет импортироваться из каталога инструкцией from *. Список __all__ в файлах __init__.py представляет собой список имен субмодулей, которые должны импортироваться,  когда  в    инструкции  from  *  указывается  имя  пакета  (каталога).  Если список __all__ отсутствует, инструкция from * не будет автоматически загружать  субмодули,  вложенные  в  каталог,  –  она  загрузит  только  имена,
определяемые инструкциями присваивания в файле __init__.py, включая любые субмодули, явно импортируемые программным кодом в этом файле. Например, инструкция from submodule import X в файле __init__.py создаст имя X в пространстве имен каталога. (Мы поближе познакомимся со списком __all__ в следующих постах.)
Эти файлы можно оставить пустыми, если вам не требуется выполнять специальных действий. Однако для успешного выполнения операции импортирования каталогов они должны существовать обязательно.

Эти файлы можно оставить пустыми, если вам не требуется выполнять специальных действий. Однако для успешного выполнения операции импортирования каталогов они должны существовать обязательно.


## Используйте __main__.py

Разбиение логики по разным файлам упрощает редактирование и поддержку приложения.
```
.
├── README.me
├── requirements.txt
├── setup.py
└── src
    ├── __init__.py
    ├── client.py
    ├── logic.py
    ├── models.py
    └── run.py


```
Но пользователю, который склонировал проект из репозитория будет непонятно — какой из этих файлов главный. Где же искать знакомую строку if __name__ == '__main__'? Вот здесь-то __main__.py и способен проявить себя.
```py

__main__.py

```
Файл __main__.py вызывается при запуске проекта с флагом модуля — -m. И это весьма удобно, если код предназначен и для использования в качестве модуля, и для запуска из консоли. Думайте об этом файле, как о месте куда можно класть всё, что вы обычно кладёте внутрь if __name__ == '__main__'. 
Давайте изменим проект из примера выше соответственно:
```

.
├── README.me
├── requirements.txt
├── setup.py
└── myapp
    ├── __init__.py
    ├── __main__.py
    ├── client.py
    ├── logic.py
    ├── models.py

```
Теперь можно просто запускать проект как обычный модуль.
```py
python -m myapp
```
__main__.py будет выполняться автоматически. Это идеальное место для размещения интерфейса командной строки и обработки входных аргументов!

