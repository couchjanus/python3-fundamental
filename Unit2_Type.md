# Типы и модель данных

## Неявная типизация
Неявная типизация означает, что при объявлении переменной вам не нужно указывать её тип, при явной – это делать необходимо. Вот как будет выглядеть объявление целочисленной переменной в Java и Python.

Java:
```java
int a = 1;
```
Python:
```py
a = 1
```

Также языки бывают с динамической и статической типизацией. В первом случае тип переменной определяется непосредственно при выполнении программы, во втором – на этапе компиляции. Python – это динамически типизированный язык, такие языки как С, C#, Java – статически типизированные.

Сильная типизация не позволяет производить операции в выражениях с данными различных типов, слабая – позволяет. В языках с сильной типизацией вы не можете складывать например строки и числа, нужно все приводить к одному типу. К первой группе можно отнести Python, Java, ко второй – С и С++.


## Типы данных в Python
В Python типы данных можно разделить на встроенные в интерпретатор (built-in) и не встроенные, которые можно использовать при импортировании соответствующих модулей.

К основным встроенным типам относятся:

- None (неопределенное значение переменной)
- Логические переменные (Boolean Type)
- Числа (Numeric Type)
- Списки (Sequence Type)
- Строки (Text Sequence Type )
- Бинарные списки (Binary Sequence Types)
- Множества (Set Types)
-Словари (Mapping Types)

### Числа (Numeric Type)
- int – целое число
- float – число с плавающей точкой
- complex – комплексное число
### Списки (Sequence Type)
list – список
tuple – кортеж
range – диапазон
### Строки (Text Sequence Type )
str
### Бинарные списки (Binary Sequence Types)
bytes – байты
bytearray – массивы байт
memoryview – специальные объекты для доступа к внутренним данным объекта через protocol buffer
### Множества (Set Types)
set – множество
frozenset – неизменяемое множество
### Словари (Mapping Types)
dict – словарь

## Модель данных
Для того, чтобы объявить и сразу инициализировать переменную необходимо написать её имя, потом поставить знак равенства и значение, с которым эта переменная будет создана. Например строка:

b = 5
объявляет переменную b и присваивает ей значение 5.

Целочисленное значение 5 в рамках языка Python является объектом. Объект, в данном случае – это абстракция для представления данных, данные – это числа, списки, строки и т.п. При этом, под данными следует понимать как непосредственно сами объекты, так и отношения между ними. Каждый объект имеет три атрибута – это идентификатор, значение и тип. Идентификатор – это уникальный признак объекта, позволяющий отличать объекты друг от друга, а значение – непосредственно информация, хранящаяся в памяти, которой управляет интерпретатор.

При инициализации переменной, на уровне интерпретатора, происходит следующее:
- создается целочисленный объект 5 (можно представить, что в этот момент создается ячейка и 5 кладется в эту ячейку);
- данный объект имеет некоторый идентификатор, значение: 5, и тип: целое число;
- посредством оператора “=” создается ссылка между переменной b и целочисленным объектом 5 (переменная b ссылается на объект 5).

Имя переменной не должно совпадать с ключевыми словами интерпретатора Python. Список ключевых слов можно получить непосредственно в программе, для этого нужно подключить модуль keyword и воспользоваться командой keyword.kwlist.
```py
import keyword
print("Python keywords: ", keyword.kwlist)
```
Проверить является или нет идентификатор ключевым словом можно так:
```py
keyword.iskeyword("try") # True
keyword.iskeyword("b") # False
```
Для того, чтобы посмотреть на объект с каким идентификатором ссылается данная переменная, можно использовать функцию id().
```py
a = 4
b = 5
id(a) # 1829984576
id(b) # 1829984592
a = b
id(a) # 1829984592
```
идентификатор – это некоторое целочисленное значение, посредством которого уникально адресуется объект. Изначально переменная a ссылается на объект 4 с идентификатором 1829984576, переменная b – на объект с id = 1829984592. После выполнения операции присваивания a = b, переменная a стала ссылаться на тот же объект, что и b.

## type()
Тип переменной можно определить с помощью функции type(). Пример использования приведен ниже.
```py
a = 10
b = "hello"
c = (1, 2)
type(a) # <class 'int'>
type(b) # <class 'str'>
type(c) # <class 'tuple'>
```
## Изменяемые и неизменяемые типы данных
В Python существуют изменяемые и неизменяемые типы.

К неизменяемым (immutable) типам относятся: целые числа (int),  числа с плавающей точкой (float), комплексные числа (complex), логические переменные (bool), кортежи (tuple), строки (str) и неизменяемые множества (frozen set).

К изменяемым (mutable) типам относятся: списки (list), множества (set), словари (dict).

при создании переменной, вначале создается объект, который имеет уникальный идентификатор, тип и значение, после этого переменная может ссылаться на созданный объект.

Неизменяемость типа данных означает, что созданный объект больше не изменяется. Например, если мы объявим переменную k = 15, то будет создан объект со значением 15, типа int и идентификатором, который можно узнать с помощью функции id().
```py
k = 15
id(k) # 1672501744
type(k) # <class 'int'>
```
Объект с id = 1672501744 будет иметь значение 15 и изменить его уже нельзя.

Если тип данных изменяемый, то можно менять значение объекта. Например, создадим список [1, 2], а потом заменим второй элемент на 3.
```py
a = [1, 2]
id(a) # 47997336
a[1] = 3
a # [1, 3]
id(a) # 47997336
```
Как видно, объект на который ссылается переменная a, был изменен.


## Арифметические операции

Язык Python, благодаря наличию огромного количества библиотек для решения разного рода вычислительных задач, сегодня является конкурентом таким пакетам как Matlab и Octave.

в Python существует три встроенных числовых типа данных:
- целые числа (int);
- вещественные числа (float);
- комплексные числа (complex).

Если в качестве операндов некоторого арифметического выражения используются только целые числа, то результат тоже будет целое число. Исключением является операция деления, результатом которой является вещественное число. При совместном использовании целочисленных и вещественных переменных, результат будет вещественным.

## Арифметические операции с целыми и вещественными числами

### Сложение.
Складывать можно непосредственно сами числа…
```py
3+2
```
либо переменные, но они должны предварительно быть проинициализированы.
```py
a = 3
b = 2
a + b
```
Результат операции сложения можно присвоить другой переменной…
```py
a = 3
b = 2
c = a + b
print(c)
```
либо ей же самой, в таком случае можно использовать полную или сокращенную запись, полная выглядит так
```py
a = 3
b = 2
a = a + b
print(a)
```
сокращенная так
```py
a = 3
b = 2
a += b
print(a)
```

### Вычитание.
```py
a = 5
b = 7
a - b
```
### Умножение.
```py
a = 4
a *= 10
print(a)
```
### Деление.
```py
a = 7
b = 4
a / b
```
### Получение целой части от деления.
```py
a = 7
b = 4
a // b
```
### Получение остатка от деления.
```py
a = 7
b = 4
a % b
```
### Возведение в степень.
```py
a = 4
b = 3
a ** b
```
### Работа с комплексными числами
Для создания комплексного числа можно использовать функцию complex(a, b), в которую, в качестве первого аргумента, передается действительная часть, в качестве второго – мнимая. Либо записать число в виде  a + bj.

### Создание комплексного числа.
```py
z = 1 + 2j
print(z)

x = complex(3, 2)
print(x)
```
Комплексные числа можно складывать, вычитать, умножать, делить и возводить в степень.
```py
x + z
x - z
x * z
x / z
x ** z
x ** 3
```
У комплексного числа можно извлечь действительную и мнимую части.
```py
x = 3 + 2j
x.real

x.imag
```
Для получения комплексносопряженного число необходимо использовать метод conjugate().
```py
x.conjugate()
```
## Битовые операции
В Python доступны битовые операции, их можно производить над целыми числами.

### Побитовое И (AND).
```py
p = 9
q = 3
p & q
```
### Побитовое ИЛИ (OR).
```py
p | q
```
### Побитовое Исключающее ИЛИ (XOR).
```py
p ^ q
```
### Инверсия.
```py
~p
```
### Сдвиг вправо и влево.
```py
p << 1

p >> 1
```

## Представление числа в шестнадцатеричной системе
```py
m = 124504
hex(m)
```
## Представление числа в восьмеричной системе
```py
oct(m)
```
## Представление числа в двоичной системе
```py
bin(m)
```
## Библиотека (модуль) math
В стандартную поставку Python входит библиотека math, в которой содержится большое количество часто используемых математических функций.

Для работы с данным модулем его предварительно нужно импортировать.
```py
import math
```
### math.ceil(x)
Возвращает ближайшее целое число большее, чем x.
```py
math.ceil(3.2)
```
### math.fabs(x)
Возвращает абсолютное значение числа.
```py
math.fabs(-7)
```
### math.factorial(x)
Вычисляет факториал x.
```py
math.factorial(5)
```
### math.floor(x)
Возвращает ближайшее целое число меньшее, чем x.
```py
>>> math.floor(3.2)
```
### math.exp(x) - Вычисляет e в степени x.
```py
math.exp(3)
```
### math.log2(x) - Логарифм по основанию 2.
### math.log10(x) - Логарифм по основанию 10.

### math.log(x[, base])
По умолчанию вычисляет логарифм по основанию e, дополнительно можно указать основание логарифма.
```py
math.log2(8)
math.log10(1000)
math.log(5)
math.log(4, 8)

```
### math.pow(x, y)
Вычисляет значение x в степени y.
```py
math.pow(3, 4)
```
### math.sqrt(x)
Корень квадратный от x.
```py
math.sqrt(25)
```
### Тригонометрические функции
- math.cos(x)
- math.sin(x)
- math.tan(x)
- math.acos(x)
- math.asin(x)
- math.atan(x)

### константы
- math.pi - Число пи.
- math.e - Число е.

## Условные операторы и циклы

## Условный оператор ветвления if
Оператор ветвления if  позволяет выполнить определенный набор инструкций в зависимости от некоторого условия. Возможны следующие варианты использования.

1. Конструкция if
```py
if выражение:
    инструкция_1
    инструкция_2
    ...
    инструкция_n
```
После оператора if  записывается выражение. Если это выражение истинно, то выполняются инструкции, определяемые данным оператором. Выражение является истинным, если его результатом является число не равное нулю, непустой объект, либо логическое True. После выражения нужно поставить двоеточие “:”.

блок кода, который необходимо выполнить, в случае истинности выражения, отделяется четырьмя пробелами слева!

```py
if 1:
   print("hello 1") # Напечатает: hello 1

a = 3
if a == 3:
    print("hello 2") # Напечатает: hello 2

a = 3
if a > 1:
   print("hello 3") # Напечатает: hello 3

lst = [1, 2, 3]
if lst :
   print("hello 4") # Напечатает: hello 4
```

2. Конструкция if – else
Бывают случаи, когда необходимо предусмотреть альтернативный вариант выполнения программы. Т.е. при истинном условии нужно выполнить один набор инструкций, при ложном – другой. Для этого используется конструкция if – else.
```py
if выражение:
    инструкция_1
    инструкция_2
    ...
    инструкция_n
else:
    инструкция_a
    инструкция_b
    ...
    инструкция_x
```
Примеры.
```py
a = 3
if a > 2:
   print("H")
else:
   print("L") # Напечатает: H

a = 1
if a > 2:
   print("H")
else:
   print("L") # Напечатает: L
```
Условие такого вида можно записать в строчку, в таком случае оно будет представлять собой тернарное выражение.
```py 
a = 17
b = True if a > 10 else False
print(b) # будет напечатано: True
```
3. Конструкция if – elif – else
Для реализации выбора из нескольких альтернатив можно использовать конструкцию if – elif – else.
```py
if выражение_1:
    инструкции_(блок_1)
elif выражение_2:
    инструкции_(блок_2)
elif выражение_3:
    инструкции_(блок_3)
else:
    инструкции_(блок_4)
```
Пример.
```py
a = int(input("введите число:"))
if a < 0:
   print("Neg")
elif a == 0:
   print("Zero")
else:
   print("Pos")
```
Если пользователь введет число меньше нуля, то будет напечатано “Neg“, равное нулю – “Zero“, большее нуля – “Pos“.

## Оператор цикла while
Оператор цикла while  выполняет указанный набор инструкций до тех пор, пока условие цикла истинно. Истинность условия определяется также как и в операторе if. 
```py
while выражение:
    инструкция_1
    инструкция_2
    ...
    инструкция_n
```
Выполняемый набор инструкций называется телом цикла.

```py
a = 0
while a < 7:
   print("A")
   a += 1 # Буква “А” будет выведена семь раз в столбик.
```
### Пример бесконечного цикла.
```py
a = 0
while a == 0:
   print("A")
```
## Операторы break и continue
При работе с циклами используются операторы break  и continue.

Оператор break  предназначен для досрочного прерывания работы цикла while.
```py
a = 0
while a >= 0:
   if a == 7:
       break
   a += 1
   print("A")
   # выход из цикла произойдет при достижении переменной a  значения 7. Если бы не было этого условия, то цикл выполнялся бы бесконечно.

```
### Оператор continue
Оператор continue  запускает цикл заново, при этом код, расположенный после данного оператора, не выполняется.

```py
a = -1
while a < 10:
   a += 1
   if a >= 7:
       continue
   print("A")
```
При запуске данного кода символ “А” будет напечатан 7 раз, несмотря на то, что всего будет выполнено 11 проходов цикла.

### Оператор цикла for
Оператор for  выполняет указанный набор инструкций заданное количество раз, которое определяется количеством элементов в наборе.

```py
for i in range(5):
   print("Hello") # В результате “Hello” будет выведено пять раз.
```
Внутри тела цикла можно использовать операторы break  и continue, принцип работы их точно такой же как и в операторе while.

Если у вас есть заданный список, и вы хотите выполнить над каждым элементом определенную операцию (возвести в квадрат и напечатать получившееся число), то с помощью for  такая задача решается так.
```py
lst = [1, 3, 5, 7, 9]
for i in lst:
   print(i ** 2)
```
Также можно пройти по всем буквам в строке.
```py
word_str = "Hello, world!"
for l in word_str:
   print(l) # Строка “Hello, world!” будет напечатана в столбик.
```

## Работа со списками (list)
Список (list) – это структура данных для хранения объектов различных типов. Если вы использовали другие языки программирования, то вам должно быть знакомо понятие массива. Так вот, список очень похож на массив, только, как было уже сказано выше, в нем можно хранить объекты различных типов. Размер списка не статичен, его можно изменять. Список по своей природе является изменяемым типом данных. Про типы данных можно подробно прочитать здесь. Переменная, определяемая как список, содержит ссылку на структуру в памяти, которая в свою очередь хранит ссылки на какие-либо другие объекты или структуры.

Список является изменяемым типом данных. При его создании в памяти резервируется область, которую можно условно назвать некоторым “контейнером”, в котором хранятся ссылки на другие элементы данных в памяти. В отличии от таких типов данных как число или строка, содержимое “контейнера” списка можно менять. 

## Создать список можно одним из следующих способов.
```py
a = [] 
type(a) # <class 'list'> 
b = list() 
type(b) # <class 'list'>
```
Также можно создать список с заранее заданным набором данных.
```py
a = [1, 2, 3] 
type(a) # <class 'list'>
```
Если у вас уже есть список и вы хотите создать его копию, то можно воспользоваться следующим способом:
```py
a = [1, 3, 5, 7] 
b = a[:] 
print(a) 
print(b) 
```
или сделать это так:
```py
a = [1, 3, 5, 7] 
b = list(a) 
print(a) 
print(b) 
```
В случае, если вы выполните простое присвоение списков друг другу, то переменной b будет присвоена ссылка на тот же элемент данных в памяти, на который ссылается a, а не копия списка а. Т.е. если вы будете изменять список a, то и b тоже будет меняться.
```py
a = [1, 3, 5, 7] 
b = a 
print(a) 
print(b) 
a[1] = 10 
print(a) 
print(b) 
```
Добавление элемента в список осуществляется с помощью метода append().
```py
a = [] 
a.append(3) 
a.append("hello") 
print(a) # [3, 'hello']
```
Для удаления элемента из списка, в случае, если вы знаете его значение, используйте метод remove(x), при этом будет удалена первая ссылка на данный элемент.
```py
b = [2, 3, 5] 
print(b) 
b.remove(3) 
print(b) # [2, 5]
```
Если необходимо удалить элемент по его индексу, воспользуйтесь командой del имя_списка[индекс].
```py
c = [3, 5, 1, 9, 6] 
print(c) 

del c[2] 
print(c) # [3, 5, 9, 6]
```
Изменить значение элемента списка, зная его индекс, можно напрямую к нему обратившись.
```py
d = [2, 4, 9] 
print(d) 

d[1] = 17 
print(d) # [2, 17, 9]
```
Очистить список можно просто заново его проинициализировав, так как будто вы его вновь создаете. Для получения доступа к элементу списка укажите индекс этого элемента в квадратных скобках.
```py
a = [3, 5, 7, 10, 3, 2, 6, 0] 
a[2] 
```
Можно использовать отрицательные индексы, в таком случае счет будет идти с конца, например для доступа к последнему элементу списка можно использовать вот такую команду:
```pt
a[-1] 
```
Для получения из списка некоторого подсписка в определенном диапазоне индексов, укажите начальный и конечный индекс в квадратных скобках, разделив их двоеточием.
```py
a[1:4] 
```
## Методы списков
### list.append(x)
Добавляет элемент в конец списка. Ту же операцию можно сделать так a[len(a):] = [x].
```py
a = [1, 2] 
a.append(3) 
print(a) 
```
### list.extend(L)
Расширяет существующий список за счет добавления всех элементов из списка L. Эквивалентно команде a[len(a):] = L.
```py
a = [1, 2] 
b = [3, 4] 
a.extend(b) 
print(a) 
```
### list.insert(i, x)
Вставить элемент x в позицию i.  Первый аргумент – индекс элемента после которого будет вставлен элемент x.
```py
a = [1, 2] 
a.insert(0, 5) 
print(a) 

a.insert(len(a), 9) 
print(a) 
```
### list.remove(x)
Удаляет первое вхождение элемента x из списка.
```py
a = [1, 2, 3] 
a.remove(1) 
print(a) 
```
### list.pop([i])
Удаляет элемент из позиции i и возвращает его. Если использовать метод без аргумента, то будет удален последний элемент из списка.
```py
a = [1, 2, 3, 4, 5] 
print(a.pop(2)) 
 
print(a.pop()) 
 
print(a) 
```
### list.clear()
Удаляет все элементы из списка. Эквивалентно del a[:].
```py
a = [1, 2, 3, 4, 5] 
print(a) 

a.clear() 
print(a) # []
```
### list.index(x[, start[, end]])
Возвращает индекс элемента.
```py
a = [1, 2, 3, 4, 5] 
a.index(4) 
```
### list.count(x)
Возвращает количество вхождений элемента x в список.
```py
a=[1, 2, 2, 3, 3] 
print(a.count(2)) 
```
### list.sort(key=None, reverse=False)
Сортирует элементы в списке по возрастанию. Для сортировки в обратном порядке используйте флаг reverse=True. Дополнительные возможности открывает параметр key.
```py
a = [1, 4, 2, 8, 1] 
a.sort() 
print(a) 
```
### list.reverse()
Изменяет порядок расположения элементов в списке на обратный.
```py
a = [1, 3, 5, 7] 
a.reverse() 
print(a) 
```
### list.copy()
Возвращает копию списка. Эквивалентно a[:].
```py
a = [1, 7, 9] 
b = a.copy() 
print(a) 
print(b) 
b[0] = 8 
print(a) 
print(b) 

```
