# Файловая система

Для работы с файлами используется специальный объект файла, который содержит в себе функции для открытия, закрытия файлов, чтения и записи данных. 

## Открыть файл
Функция open создает файловый объект для работы с файлами:

open(file[, mode='r', buffering=-1, encoding=None, errors=None, 
newline=None, closefd=True, opener=None])

Функция принимает следующие аргументы:
- file – обязательный аргумент строку, содержащую путь к файлу (может быть абсолютным или относительным)
- mode – режим открытия файла. Режим открытия файла определяет допустимые операции доступа к файлу
- buffering – устанавливает размер буферизации при работе с файлом. Буфер – это область памяти в которой накапливается информация для последующего вывода (или чтения) на стандартное устройство, поскольку данные считываются и записываются блоками. По умолчанию он выключен, и чтение/запись идет напрямую с диска на диск. Для включения буфера параметр buffering должен быть отличным от нуля.
- encoding – указание кодировки, если кодировка не указана, то используется кодировка платформы.  encoding, нужен только в текстовом режиме чтения файла.
- errors – указание как обрабатывать ошибки кодирования/декодирования
- newline – по умолчанию включен режим универсальной новой строки: любой завершающий символ сводится к '\n'
- closefd – по умолчанию при закрытии файла, файловый дескриптор будет доступен, иначе – нет
- opener – указание иной функции открытия файла

Функция возвращает файловый объект. Обязателен только первый аргумент. Если остальные параметры отсутствуют, файл будет доступен на чтение. 

### Режимы работы с файлом
Режим открытия файла определяет допустимые операции доступа к файлу:

w   Открыть файл для записи. Если такой файл уже существует,
    то его содержимое исчезает(если это возможно).
r   Открыть файл только для чтения (является значением по умолчанию).
a   Открыть файл для добавления, т.е. записи в конец файла. 
    Предыдущее содержимое файла сохраняется.
r+  Открыть файл для записи/чтения, содержимое файла сохраняется.
w+  Открыть файл для записи/чтения, содержимое файла исчезает(см w).
r+b Открыть двоичный (если такие файлы поддерживаются операционной
    системой) файл для записи/чтения, содержимое файла сохраняется.
w+b Открыть двоичный файл для записи/чтения, содержимое файла исчезает(см w).
rb  Открыть двоичный файл только для чтения.
wb  Открыть двоичный файл для записи. Если такой файл уже существует, 
    то его содержимое исчезает(если это возможно).
```py

f = open('/tmp/workfile', 'w')

```
Параметр режим необязателен: если он опущен — предполагается, что он равен 'r'. 

Режим '+' может быть добавлен к остальным режимам. 
Режимы могут быть объединены. Для открытия файла в бинарном режиме на чтение можно добавить 'rb'. По умолчанию режим равен 'rt'. Нельзя открывать бинарные файлы (такие как jpeg, exe, doc) в текстовом режиме! Это может привести к тому, что файлы будут испорчены.

Файлы открытые методом open() должны быть закрыты методом close(). Закрывать файл необходимо сразу же после выполнения задач по чтению из файла или записи в файл для синхронизации файловых операций и освобождения системных ресурсов. 


## Методы работы с файлом

### Метод read([число_байт])    

Читает из файла, открытого для чтения число байтов, указанных в качестве аргумента. Если метод вызывается без параметров, то читается весь файл, если файл был прочитан до конца (встретился символ EOF), то метод read() возвращает пустую строку
```py

f = open('text.txt', 'r')
f.read(5)

# метод read, читающий файл целиком

f = open('text.txt')
f.read()

```
## Построчное чтение текстового файла

### Метод readline()  

Читает одну строку файла до символа перевода строки (включая сам символ \n). Если строка состоит только из символа перевода строки, то метод readline() возвращает пустую строку. (Если в конце файла нет пустой строки с символом \n, то возвращаемый результат неопределён)

```py

# В первой строке файла f_in записаны два целых числа через пробел. 
# Записать во второй файл (f_out) сумму этих двух чисел.

fin  = open('sum.in',  'r') # объект связан с файлом из которого будем получать данные
fout = open('sum.out', 'w') # объект связан с файлом в который будем записывать

# Считываем строку файла при помощи метода readline(),
# результат разбиваем на поля по пробельным символам методом split()
# и записываем в список InputData
line = fin.readline().split()
# Теперь в элементах списка line[0] и line[1]
# записаны два входных числа в виде строк.
# Преобразуем их к типу int и запишем их сумму в переменную sum
sum = int(line[0]) + int(line[1])
# Выведем результат в файл, но перед этим преобразуем переменную sum в тип строки (str)
fout.write(str(sum))
# Закроем файлы
fin.close()
fout.close()

```

### Построчное чтение файла цикл while

Здесь применяется цикл while, который непрерывно читает из файла, пока метод readline() продолжает возвращать данные. В случае конца файла (EOF) цикл while останавливается, и файловый объект закрывается, освобождая ресурсы для других программ.
```py

# определим имя файла, который читаем
filename = "text.txt"

# открываем файл для чтения
filehandle = open(filename, 'r')  
while True:  
    # читаем одну строку
    line = filehandle.readline()
    if not line:
        break
    print(line)

# закрываем указатель на этот файл
filehandle.close()  


```
### протокол итераторов
 
Файл сам может выступать в роли итератора:
```py

# определим имя файла, который читаем
filename = "test.txt"

for line in open(filename, 'r'):  
    print(line)

```
Здесть применяется цикл for в комбинации с итератором in. Текущая строка определяется с помощью итератора in, считывается из файла, и её содержимое подаётся на выход stdout. Python скрывает открытие и закрытие файла, когда закончится исполнение. 


### Метод readlines([размер_строки])  
Читает все строки файла в список. Читаются только законченные строки. Необязательный параметр размер_строки дополняет читаемую строку, и если она меньше указанной длины читает дальше, до достижения указанного числа символов

Функция readline() без параметра читает всю строку, наличие параметра указывает функции максимальное число символов строки, которое будет прочитано. Прочитать все строки и вернуть список строк:
```py

file.readlines()

```
С помощью метода readlines() можно получить список строк файла непосредственно. Тогда перебрать строки можно обычным способом, итерацией по списку.


### Запись в текстовый файл

Метод write(строка) пишет в файл указанную строку, возвращая количество записанных символов

Чтобы открыть текстовый файл на запись, необходимо применить режим w (перезапись) или a (дозапись). Затем для записи применяется метод write(str), в который передается записываемая строка. Стоит отметить, что записывается именно строка, поэтому, если нужно записать числа, данные других типов, то их предварительно нужно конвертировать в строку.

Запись в файл:
```py

f = open('hello.txt', 'w')
f.write('Hello, World!')
f.close()


f = open('hello.txt', 'w')
f.write('Hello, ')
f.write('World!')
f.close()

# Дозапись в файл:

f = open('hello.txt', 'a')
f.write('Hello, ')
f.write('World!')
f.close()

```
Дозапись выглядит как добавление строку к последнему символу в файле, поэтому, если необходимо сделать запись с новой строки, то можно использовать эскейп-последовательность "\n".


### записать в файл список:
```py

l = [str(i)+str(i-1) for i in range(20)]

# Откроем файл на запись:

f = open('list.txt', 'w')
# Запись в файл осуществляется с помощью метода write:

for index in l:
    f.write(index + '\n')

# метод write возвращает число записанных символов.

# После окончания работы с файлом его обязательно нужно закрыть с помощью метода close:

f.close()


# Откроем файл на чтение, и прочитаем строки.

f = open('list.txt', 'r')
l = [line.strip() for line in f]
l
f.close()

```

Записать в исходный файл input 10 строк в каждой из которых находится случайное число из отрезка [10, 99]. Получить из этого файла данные чтением построчно с суммированием и отправить среднее арифметическое в файл output. (Представить вещественное число в экспоненциальном формате).
```py

from random import randint
fin = open('input1', 'w+')
try:
    for j in range(10):
        fin.write(str(randint(10, 99)) + '\n')
    s = 0
    for j in fin:
        s += int(j)
finally:
    fin.close()
fout = open('output1', 'w')
try:
    fout.write('{:e}'.format(s/10))
finally:
    fout.close()

```

## Запись строк в файл: file.writelines()

Прочитать файл и записать его содержимое в другой файл:
```py

f = open('text.txt')

lines = f.readlines()
f.close()

lines[0] = "This is a file2.txt \n" # изменяем 1-ю строку
f = open('file2.txt','w')
f.writelines(lines)
f.close()


```
## Произвольный доступ
По умолчанию метод read() читает данные последовательно по порядку, от начала и до конца файла. Для произвольного доступа к файлу есть Метод seek:

### Метод seek(offset[, whence])
- offset – смещение в байтах относительно начала файла;
- whence – по умолчанию равен нулю, указывает на то, что смещение берется относительно начала файла.

Перемещает указатель текущего положения файла на заданное количество байт от позиции, указанной вторым аргументом. (Значение 0 параметра whence(откуда) – смещение от начала файла, значение 1 применяется для текущей позиции в файле, а значение 2 в качестве точки отсчёта – конец файла. Параметр откуда по умолчанию устанавливается в 0, используя начало файла в качестве точки отсчёта.)
```py

f = open('my_file', 'w')
f.write('01234567890123456789')
print(f.seek(5))
f.write('Hello, World!')
f.close()
f = open('my_file')
print(f.read())


```
### Метод tell()  
Метод tell() возвращает целое число – текущее положение файлового указателя представленного в виде числа байт от начала файла, если файл открыт в двоичном режиме и число символов, если в текстовом режиме.
При работе с текстовыми файлами (открытыми без символа b в строке режима), выполнять позиционирование (seek) позволяется только от начала файла (за исключением прокрутки в конец файла с использованием seek(0, 2)).
```py

f = open('my_file', 'w')
f.write('01234567890123456789')
print(f.seek(5))
print(f.tell())
f.write('Hello, World!')
print(f.tell())
f.close()
f = open('my_file')
print(f.tell())
print(f.read())
print(f.tell())

```

## Менеджеры контекста

Управляющий контекстом (менеджер) следит за инициализацией и финализацией данного контекста, в частности определяет действия которые должны происходить до и после выполнения блока кода.

Менеджеры контекста часто используются в задачах сходных с:
- сохранением и восстановлением глобального состояния;
- блокировкой и разблокировкой ресурсов;
- открытием и закрытиям файлов.

Менеджеры контекста позволяют выделять и освобождать ресурсы строго по необходимости. 
Обычно используется совместно с инструкцией with, позволяющей выполнение описанного в ней блока в некотором контексте исполнения. Однако не возбраняется и прямое обращение к методам менеджера.

Предположим, у вас есть две связанные операции, которые вы хотите исполнить в паре, поместив между ними блок кода. Менеджеры контекста позволяют сделать именно это:
```py

with open('some_file', 'w') as opened_file:
    opened_file.write('Hola!')

```
Код выше открывает файл, записывает в него данные и закрывает файл после этого. При возникновении ошибки при записи данных в файл менеджер контекста попробует его закрыть. Этот код эквивалентен следующему:
```py

file = open('some_file', 'w')
try:
    file.write('Hola!')
finally:
    file.close()

```
Основное преимущество использования with - это гарантия закрытия файла вне зависимости от того, как будет завершён вложенный код.

Распространенный паттерн использования контекстных менеджеров - блокирование и разблокирование ресурсов, а также закрытие открытых файлов.

Другим (более удобным) способом гарантированного закрытия файла является использование инструкции менеджера контекста with-as:
```py

with open('sum.in',  'r') as fin:
    line = fin.readline().split()
#...
with open('sum.out', 'w') as fout:
    fout.write(str(sum))

with open("hello.txt", "w") as file:
    file.write("hello world")

```
### Дозапись в файл:

with open("hello.txt", "a") as file:
    file.write("\ngood bye, world")

# определим имя файла, который читаем
filename = "test.txt"

with open(filename, 'r') as filehandle:  
    for line in filehandle:
        print(line)


### метод print()
Еще один способ записи в файл представляет стандартный метод print(), который применяется для вывода данных на консоль:

with open("hello.txt", "a") as hello_file:
    print("Hello, world", file=hello_file)


Комбинация оператора with и команды open() открывает файл только один раз.

Внутри интерпретатора Python создаётся блок try–finally, чтобы инкапсулировать чтение из файла:
```py

try:  
    filehandle = open(filename, 'r')
    # что-то делаем
finally:  
    filehandle.close()

```

### Чтение определённой строки из файла
Чтобы это сделать, применим счётчик и напечатаем соответствующую строку, когда дойдём до неё, проходя итерациями по файлу.
```py

# определим имя файла, который читаем
filename = "test.txt"

# определим номер строки
line_number = 3

print ("line %i of %s is: " % (line_number, filename))

with open(filename, 'r') as filehandle:  

    current_line = 1  
    for line in filehandle:
        if current_line == line_number:
            print(line)
            break
        current_line += 1


```

### Чтение из всего файла целиком
```py

# определим имя файла, который читаем
filename = "test.txt"

with open(filename, 'r') as filehandle:  
    filecontent = filehandle.read()
    print (filecontent)


```
метод readlines() В отличие от read(), содержимое файла сохраняется в список, где каждый элемент есть строка содержимого:
```py

# определим имя файла, который читаем
filename = "test.txt"

with open(filename, 'r') as filehandle:  
    filecontent = filehandle.readlines()
    for line in filecontent:
        print (line)

```
Хотя readlines() будет читать содержимое из файла, пока не наткнётся на EOF (конец файла), вы также можете ограничить количество прочитанного параметром sizehint — числом байт, которое нужно прочесть.

## Закрытие файла
Для закрытия файла есть метод close(). Обычно файл закрывается сам после того, как вы выходите из программы, но файлы нужно закрывать вручную по нескольким причинам.

Питон может буферизировать запись в файл ваших данных, что может привести к неожиданным эффектам и возникновению ошибок.
У операционной системы есть ограничение на число одновременно открытых файлов.
При доступе к файлу из разных мест одновременно и на чтение, и на запись необходимо синхронизировать файловые операции. Буферизация записи может привести к тому, что запись уже произошла, а данных в файле еще нет.
Для полной уверенности в закрытии файла можно использовать блок try/finally:
```py

try:
   # Тут идет запись в файл
finally:
   file.close()

# Можно также использовать менеджер контекста, который в любом случае закроет файл:

with open("my_file") as somefile:
   do_something(somefile)

```
Если вы все же не хотите закрывать файл, то синхронизировать многопользовательский доступ к файлу на чтение/запись можно с помощью функции flush(), которая актуализирует все операции записи на диск. При этом возможна блокировка файла на чтение.


## Бинарные файлы

Бинарные файлы в отличие от текстовых хранят информацию в виде набора байт. 

## Модуль pickle
Для записи в файл сложных типов данных: кортежи, списки, множества, словари, функции и экземпляры классов можно использовать модуль pickle. Этот модуль позволяет избавить разработчика программы от написания сложных фрагментов кода для работы с файлами. Модуль реализует двоичные протоколы для консервации и расконсервации структуры объектов. Консервация представляет собой процесс, при котором объект преобразуется в поток байтов, а расконсервация – это обратная операция, в результате которой, поток байтов (из двоичного файла или байт-подобного объекта) преобразуется в объект. 

- Для консервации объектов используется метод dump(). 
dump(obj, file): записывает объект obj в бинарный файл file

- Обратную операцию обеспечивает метод load(). 
load(file): считывает данные из бинарного файла в объект

Файлы должны открываться в режимах r+b, w+b, rb и wb, т. е. в режимах бинарных файлов.
```py

import pickle
t1 = [1, 2, 3]
s = pickle.dumps(t1)

t2 = pickle.loads(s)
print t2

```
t1 и t2 будут двумя разными объектами, хотя и идентичными.
```py

import pickle
 
FILENAME = "user.dat"
 
name = "Tom"
age = 19
 
with open(FILENAME, "wb") as file:
    pickle.dump(name, file)
    pickle.dump(age, file)
 
with open(FILENAME, "rb") as file:
    name = pickle.load(file)
    age = pickle.load(file)
    print("Имя:", name, "\tВозраст:", age)
```

С помощью функции dump последовательно записываются два объекта. Поэтому при чтении файла также последовательно посредством функции load мы можем считать эти объекты.

Подобным образом мы можем сохранять и извлекать из файла наборы объектов:
```py

import pickle
 
FILENAME = "users.dat"
 
users = [
    ["Tom", 28, True],
    ["Alice", 23, False],
    ["Bob", 34, False]
]
 
with open(FILENAME, "wb") as file:
    pickle.dump(users, file)
 
 
with open(FILENAME, "rb") as file:
    users_from_file = pickle.load(file)
    for user in users_from_file:
        print("Имя:", user[0], "\tВозраст:", user[1], "\tЖенат(замужем):", user[2])

```
В зависимости от того, какой объект мы записывали функцией dump, тот же объект будет возвращен функцией load при считывании файла.


## Модуль shelve
 
Для работы с бинарными файлами в Python может применяться еще один модуль - shelve. Он сохраняет объекты в файл с определенным ключом. Затем по этому ключу может извлечь ранее сохраненный объект из файла. Процесс работы с данными через модуль shelve напоминает работу со словарями, которые также используют ключи для сохранения и извлечения объектов.

Для открытия файла модуль shelve использует функцию open():
```py
open(путь_к_файлу[, flag="c"[, protocol=None[, writeback=False]]])

```
Где параметр flag может принимать значения:

- c: файл открывается для чтения и записи (значение по умолчанию). Если файл не существует, то он создается.
- r: файл открывается только для чтения.
- w: файл открывается для записи.
- n: файл открывается для записи Если файл не существует, то он создается. Если он существует, то он перезаписывается

Для закрытия подключения к файлу вызывается метод close():
```py

import shelve
d = shelve.open(filename)
d.close()

```
Либо можно открывать файл с помощью оператора with. Сохраним и считаем в файл несколько объектов:
```py

import shelve
 
FILENAME = "states2"
with shelve.open(FILENAME) as states:
    states["London"] = "Great Britain"
    states["Paris"] = "France"
    states["Berlin"] = "Germany"
    states["Madrid"] = "Spain"
 
with shelve.open(FILENAME) as states:
    print(states["London"])
    print(states["Madrid"])

```
Запись данных предполагает установку значения для определенного ключа:
```py
states["London"] = "Great Britain"

```
А чтение из файла эквивалентно получению значения по ключу:
```py
print(states["London"])

```
В качестве ключей используются строковые значения.

При чтении данных, если запрашиваемый ключ отсутствует, то генерируется исключение. В этом случае перед получением мы можем проверять на наличие ключа с помощью оператора in:
```py

with shelve.open(FILENAME) as states:
    key = "Brussels"
    if key in states:
        print(states[key])

```
Также мы можем использовать метод get(). Первый параметр метода - ключ, по которому следует получить значение, а второй - значение по умолчанию, которое возвращается, если ключ не найден.
```py

with shelve.open(FILENAME) as states:
    state = states.get("Brussels", "Undefined")
    print(state)

```
Используя цикл for, можно перебрать все значения из файла:
```py

with shelve.open(FILENAME) as states:
    for key in states:
        print(key," - ", states[key])

```
Метод keys() возвращает все ключи из файла, а метод values() - все значения:
```py

with shelve.open(FILENAME) as states:
 
    for city in states.keys():
        print(city, end=" ")        # London Paris Berlin Madrid 
    print()
    for country in states.values():
        print(country, end=" ")     # Great Britain France Germany Spain 

```
Еще один метод items() возвращает набор кортежей. Каждый кортеж содержит ключ и значение.
```py

with shelve.open(FILENAME) as states:
 
    for state in states.items():
        print(state)

```
## Обновление данных
Для изменения данных достаточно присвоить по ключу новое значение, а для добавления данных - определить новый ключ:
```py

import shelve
 
FILENAME = "states2"
with shelve.open(FILENAME) as states:
    states["London"] = "Great Britain"
    states["Paris"] = "France"
    states["Berlin"] = "Germany"
    states["Madrid"] = "Spain"
 
with shelve.open(FILENAME) as states:
 
    states["London"] = "United Kingdom"
    states["Brussels"] = "Belgium"
    for key in states:
        print(key, " - ", states[key])

```
## Удаление данных
Для удаления с одновременным получением можно использовать функцию pop(), в которую передается ключ элемента и значение по умолчанию, если ключ не найден:
```py

with shelve.open(FILENAME) as states:
 
    state = states.pop("London", "NotFound")
    print(state)

# Также для удаления может применяться оператор del:

with shelve.open(FILENAME) as states:
 
    del states["Madrid"]    # удаляем объект с ключом Madrid

# Для удаления всех элементов можно использовать метод clear():

with shelve.open(FILENAME) as states:
 
    states.clear()

```
## модуль struct
Стандартный модуль struct позволяет преобразовывать объекты в структуры C в виде строк в бинарном формате и обратно. Данные в строке располагаются в соответствии со строкой формата. Эти возможности могут быть использованы для чтения и сохранения в двоичном формате.

## Функции этого модуля:

### pack(format, value1, value2 ...)
Возвращает строку, содержащую значения value1 ..., упакованные в соответствии с форматом. Количество и тип аргументов должны соответствовать значениям, которые требует строка формата format.

### unpack(format, string)
Распаковывает строку string в соответствии с форматом format и возвращает кортеж объектов.

### calcsize(format)
Возвращает размер структуры (т.е. длину строки), соответствующей формату format.

## Таблица основных форматов
```

===========================
Format  C Type     Python  
===========================
c       char      string of length 1      
?       Bool      bool    
i       int       integer      
l       long      integer    
f       float     float     
d       double    float    
s       char[]    string

```
Перед символом формата может идти число, обозначающее количество повторений. Например, строка формата '4h' полностью эквивалентна строке 'hhhh'. Символы пропуска между символами формата игнорируются, однако символы пропуска между числом и символом формата не допускаются.

Число перед символом формата 's' интерпретируется как длина строки, а не число повторений. То есть '10s' обозначает строку из 10 символов, в то время как '10c' – 10 раз по одному символу.

Можно изменить порядок следования байтов вручную:
- < - little-endian
- > - big-endian

упаковываем в структуру два числа – целое и float, строку из пяти символов, сохраняем в бинарный файл, а потом извлекаем из файла:
```py

from struct import *

out = open("123.bin", "wb")    
format = "if5s"                
data   = pack(format, 24, 12.48, b'12345')
out.write(data)
out.close()
input = open("123.bin", "rb")
data = input.read()
input.close()
format = "if5s"     # one integer
value,value2,value3 = unpack(format, data) # note the ',' in 'value,': 
# unpack apparently returns a n-uple
print(value)
print(value2)
print(value3)
print(calcsize(format))

```
## Модуль os

Модуль os позволяет взаимодействовать с операционной системой - узнавать/менять файловую структуру, переменные среды, узнавать имя и права пользователя и др. Программа, использующая переменные и функции модуля os, переносима с одной операционной системы на другую, так как os умеет учитывать особенности каждой ОС. Однако ряд функций используется только для Unix-подобных ОС.

Следует отметить, что часть функциональности модуля os реализуют другие модули и встроенные функции Python. Например, функция os.access() проверяет наличие доступа к файлу. Если файл открывается на чтение или запись, проще использовать функцию open(), а в случае запрета на доступ обработать возникшее исключение PermissionError.

### Каждая программа имеет текущий каталог. 
Функция os.getcwd возвращает текущий каталог:
```py

import os

cwd = os.getcwd()
print(cwd)

```
## Смена текущего каталога:
```py

os.chdir('/home')
os.getcwd()

os.chdir('./pl/Documents/python')
os.getcwd()

```
## Создать каталог:
Для создания папки применяется функция mkdir(), в которую передается путь к создаваемой папке:
```py

import os
 
# путь относительно текущего скрипта
os.mkdir("hello")

# абсолютный путь
os.mkdir("c://somedir")
os.mkdir("c://somedir/hello")
os.mkdir('TEXT')

# Создать дерево каталогов:
os.makedirs('ONE/TWO/THREE')

# Список содержимого каталога (нерекурсивный):
os.listdir()
os.listdir('/home')

# Сведения о файле|каталоге:

os.stat('/home')
os.stat('text.txt')

```

## Переименовать файл|каталог:
Для переименования вызывается функция rename(source, target), первый параметр которой - путь к исходному файлу, а второй - новое имя файла. В качестве путей могут использоваться как абсолютные, так и относительные. 
```py

import os
os.rename('text2.txt', 'xett.txt')
os.rename('TEXT', 'ETXT')
 
os.rename("C://SomeDir/somefile.txt", "C://SomeDir/hello.txt")

```
## Существование файла
Если мы попытаемся открыть файл, который не существует, то Python выбросит исключение FileNotFoundError. Для отлова исключения мы можем использовать конструкцию try...except. Однако можно уже до открытия файла проверить, существует ли он или нет с помощью метода os.path.exists(path). В этот метод передается путь, который необходимо проверить:
```py

filename = input("Введите путь к файлу: ")
if os.path.exists(filename):
    print("Указанный файл существует") 
else:
    print("Файл не существует") 

# Проверить наличие файла в текущем каталоге:

os.path.exists('my_file')

```
## Удаление каталога:
Для удаления папки используется функция rmdir(), в которую передается путь к удаляемой папке:
```py

import os
 
# путь относительно текущего скрипта
os.rmdir("hello")

# абсолютный путь
os.rmdir("c://somedir/hello")

# Удаление файла
# Для удаления вызывается функция remove(), в которую передается путь к файлу:

import os
 
os.remove("C://SomeDir/hello.txt")

```

## Функция os.walk()

Функция walk() модуля os принимает один обязательный аргумент - имя каталога.

Возвращает объект-генератор, из которого получают кортежи для каждого каталога переданной файловой иерархии.

Каждый кортеж состоит из трех элементов:
- Адрес очередного каталога в виде строки.
- В форме списка имена подкаталогов первого уровня вложенности для данного каталога.
- В виде списка имена файлов данного каталога.
Если вложенных каталогов или файлов нет, соответствующий список пуст.

## Дерево каталогов

Передадим каталог test функции os.walk():
```py

import os
tree = os.walk('test')
print(tree) # <generator object walk at 0x7f1119ca0518>
for i in tree:
    print(i)

# Если передать абсолютный адрес, то получится так:

for i in os.walk('/home/pl/test'):
    print(i)

```
Поскольку walk() возвращает генератор, повторно извлечь из него данные не получится. Если мы еще раз запустим цикл с переменной tree, то ничего не получим. Объект-генератор, с которым переменная была связана, уже был использован. Он выдал свое содержимое и больше его не содержит. Поэтому, чтобы сохранить кортежи для последующей многократной обработки, имеет смысл добавлять их в список:
```py

folder = []
for i in os.walk('test'):
    folder.append(i)

```
Теперь если потребуются полные адреса файлов можно извлекать из списка каждый кортеж, распаковывать его и соединять адрес с именем файла:
```py

for address, dirs, files in folder:
    for file in files:
            print(address+'/'+file)

```
Переменная address на каждой итерации связывается с первым элементом очередного кортежа (строкой, содержащей адрес каталога), dirs – со вторым элементом (списком подкаталогов), а files - со списками файлов этого каталога. Во вложенном цикле извлекается каждый отдельный файл из списка файлов.

Можно не распаковывать кортеж, а обращаться к его элементам по индексам (0 - адрес, 1 - список каталогов, 2 - список файлов):
```py

for i in folder:
    for j in i[2]:
           print(i[0]+'/'+j)

```
## Проверка наличия файла или каталога по указанному пути
 
Сделать это можно с помощью функции os.path.exists, которая возвращает true, если объект файловой системы существует, и false – если нет.

Функция os.path.isfile проверяет, является ли объект файлом, а os.path.isdir — является ли каталогом.

В приведенном ниже скрипте проверяется наличие объекта по указанному пользователем адресу, после чего проверяется файл это или каталог. В зависимости от вида объекта выводится та или иная информация.
```py

# Скрипт проверяет наличие пути.
# Если файл, то выводит его размер, даты создания, открытия и модификации.
# Если каталог, выводит список вложенных в него файлов и каталогов.
 
import os
import datetime
 
testpath = input('Введите адрес: ')
 
if os.path.exists(testpath):
    if os.path.isfile(testpath):
        print('ФАЙЛ')
        print('Размер:',os.path.getsize(testpath)//1024,'Кб')
        print('Дата создания:',\
              datetime.datetime.fromtimestamp(int(os.path.getctime(testpath))))
        print('Дата последнего открытия:',\
              datetime.datetime.fromtimestamp(int(os.path.getatime(testpath))))
        print('Дата последнего изменения:',\
              datetime.datetime.fromtimestamp(int(os.path.getmtime(testpath))))
    elif os.path.isdir(testpath):
        print('КАТАЛОГ')
        print('Список объектов в нем: ',os.listdir(testpath))
else:
    print ('Объект не найден')

```
В скрипте также используются функции os.path.getsize (возвращает размер файла), os.path.getctime (время создания), os.path.getatime (время последнего открытия), os.path.getmtime (дата последнего изменения). Метод datetime.datetime.fromtimestamp позволяет выводить время в местном формате.

## Вывести список файлов и подкаталогов для данного каталога: os.listdir(path)
Следующий пример рекурсивно выводит список всех файлов и подкаталогов для данного каталога:
```py

import os
def walk(dir):
  for name in os.listdir(dir):
    path = os.path.join(dir, name)
    if os.path.isfile(path):
        print path
    else:
        walk(path)
walk(path)
```

## получим статистическую информацию о текущем каталоге: 
- общий размер каталога в байтах, 
- число файлов, 
- число подкаталогов. 

Стандартная функция os.walk:

```py

import os

def foo(sums):
   for root, dirs, files in os.walk(".", topdown = False):
      for name in files:
         file = os.path.join(root, name)
         sums[0] += os.path.getsize(file)
         sums[1] += 1
         # print(file)
      for name in dirs:
         dir = os.path.join(root, name)
         sums[2] += 1
         # print(dir)
   return sums
          
   
sums = [0,0,1] # 0 bytes, 0 files, 1 directory so far

print(foo(sums))

```

## Файлы CSV
 
Одним из распространенных файловых форматов, которые хранят в удобном виде информацию, является формат csv. Каждая строка в файле csv представляет отдельную запись или строку, которая состоит из отдельных столбцов, разделенных запятыми. Собственно поэтому формат и называется Comma Separated Values. Но хотя формат csv - это формат текстовых файлов, Python для упрощения работы с ним предоставляет специальный встроенный модуль csv.
```py

import csv
 
FILENAME = "users.csv"
 
users = [
    ["Tom", 28],
    ["Alice", 23],
    ["Bob", 34]
]
 
with open(FILENAME, "w", newline="") as file:
    writer = csv.writer(file)
    writer.writerows(users)
     
 
with open(FILENAME, "a", newline="") as file:
    user = ["Sam", 31]
    writer = csv.writer(file)
    writer.writerow(user)

```
В файл записывается двухмерный список - фактически таблица, где каждая строка представляет одного пользователя. А каждый пользователь содержит два поля - имя и возраст. То есть фактически таблица из трех строк и двух столбцов.

При открытии файла на запись в качестве третьего параметра указывается значение newline="" - пустая строка позволяет корректно считывать строки из файла вне зависимости от операционной системы.

Для записи нам надо получить объект writer, который возвращается функцией csv.writer(file). В эту функцию передается открытый файл. А собственно запись производится с помощью метода writer.writerows(users) Этот метод принимает набор строк. В нашем случае это двухмерный список.

Если необходимо добавить одну запись, которая представляет собой одномерный список, например, ["Sam", 31], то в этом случае можно вызвать метод writer.writerow(user)

## Для чтения из файла нам наоборот нужно создать объект reader:
```py

import csv
 
FILENAME = "users.csv"
 
with open(FILENAME, "r", newline="") as file:
    reader = csv.reader(file)
    for row in reader:
        print(row[0], " - ", row[1])

```
## Работа со словарями

В примере выше каждая запись или строка представляла собой отдельный список, например, ["Sam", 31]. Но кроме того, модуль csv имеет специальные дополнительные возможности для работы со словарями. В частности, функция csv.DictWriter() возвращает объект writer, который позволяет записывать в файл. А функция csv.DictReader() возвращает объект reader для чтения из файла. Например:
```py

import csv
 
FILENAME = "users.csv"
 
users = [
    {"name": "Tom", "age": 28},
    {"name": "Alice", "age": 23},
    {"name": "Bob", "age": 34}
]
 
with open(FILENAME, "w", newline="") as file:
    columns = ["name", "age"]
    writer = csv.DictWriter(file, fieldnames=columns)
    writer.writeheader()
     
    # запись нескольких строк
    writer.writerows(users)
     
    user = {"name" : "Sam", "age": 41}
    # запись одной строки
    writer.writerow(user)
 
with open(FILENAME, "r", newline="") as file:
    reader = csv.DictReader(file)
    for row in reader:
        print(row["name"], "-", row["age"])

```
Запись строк также производится с помощью методов writerow() и writerows(). Но теперь каждая строка представляет собой отдельный словарь, и кроме того, производится запись и заголовков столбцов с помощью метода writeheader(), а в метод csv.DictWriter в качестве второго параметра передается набор столбцов.

При чтении строк, используя названия столбцов, мы можем обратиться к отдельным значениям внутри строки: row["name"].