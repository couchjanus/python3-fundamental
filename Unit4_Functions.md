# Пространства имен в Python
## Существует 4 типа пространств имен:  
- Встроенное. 
- Глобальное. 
- Объемлющее. 
- Локальное. 
Они обладают разными жизненными циклами. По мере выполнения программы Python создает необходимые пространства имен и удаляет их, когда потребность в них пропадает. Как правило, в любой момент времени существует множество пространств имен.

## Встроенное пространство имен 
Встроенное пространство имен содержит имена всех встроенных объектов, которые всегда доступны при работе в Python. Вы можете перечислить объекты во встроенном пространстве с помощью следующей команды: 
```py

dir(__builtins__)

```

## Глобальное пространство имен 
Глобальное пространство имен содержит имена, определенные на уровне основной программы, и создаётся сразу при запуске тела этой программы. Сохраняется же оно до момента завершения работы интерпретатора. 

Строго говоря, могут существовать и другие глобальные пространства имен. Интерпретатор также создает пространство данного типа для любого модуля, загружаемого программой при помощи выражения import.


# Функции Python

## Встроенные функции Python

В Python существуют десятки встроенных функций и классов, сотни инструментов, входящих в стандартную библиотеку Python, и тысячи сторонних библиотек на PyPI. 

## Общеизвестные функции
Если вы уже писали код на Python, эти модули должны быть вам знакомы.

### Функции Print
Функция print в Python выводит заданные объекты на стандартное устройство вывода (экран) или отправляет их текстовым потоком в файл.
 
### Полный синтаксис функции print()
```py

print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)

```
### Параметры print()
- objects – объект, который нужно вывести * обозначает, что объектов может быть несколько;
- sep – разделяет объекты. Значение по умолчанию: ‘ ‘;
- end – ставится после всех объектов;
- file – ожидается объект с методом write (string). Если значение не задано, для вывода объектов используется файл sys.stdout;
- flush – если задано значение True, поток принудительно сбрасывается в файл. Значение по умолчанию: False.
Если хотите воспользоваться аргументом sep, используйте:
```py

print(*objects, sep = 'separator')
# а не
print(*objects, 'separator')

```
### Возвращаемое значение
Функция print в Python не возвращает значений; возвращает None.
```py

# Как работает функция print в Python?
# во всех трёх выражениях передаётся только параметр objects
print("Python — это весело.")
a = 5 
# Передаётся два объекта 
print("a =", a)

b = a
# Передаётся три объекта
print('a =', a, '= b')
# каждое выражение print выводится в новой строке
# file — используется файл sys.stdout. Результат выводится на экран;
# Значение flush — False. Поток не сбрасывается принудительно.

```

### функция print() с разделителем и параметром end
```py

# Мы передали в программу параметры sep и end.
a = 5
print("a =", a, sep='00000', end='\n\n\n')
print("a =", a, sep='0', end='')

```

### функция print() с параметром file
С помощью Python print без перевода строки также можно вывести объекты в файл, указав параметр file:

sourceFile = open('python.txt', 'w')
print("Круто же, правда?", file = sourceFile)
sourceFile.close()
Код, приведенный выше, пытается открыть файл python.txt в режиме записи. Если файл не существует, программа создаёт файл python.txt и открывает его в режиме записи.

В примере мы передали в параметр file объект sourceFile. Объект-строка ‘Круто же, правда?‘ записывается в файл python.txt (после чего можно открыть его текстовым редактором).

В конце исполнения программы файл закрывается методом close().

## len
В Python нет синтаксиса вроде my_list.length() или my_string.length, вместо этого используются поначалу непривычные конструкции len(my_list) и len(my_string).
```py

words = ["Welcome", "to", "Python"]
len(words)

```
## str
К сожалению, в отличие от многих других языков программирования, в Python нельзя объединять строки и числа.
```py

version = 3
"Python " + version

```
Python отказывается приводить целое число 3 к типу строка, поэтому нужно сделать это самостоятельно, используя встроенную функцию str.
```py

version = 3
"Python " + str(version)

```
## int
Если нужно пользовательский ввод преобразовать в integer, эта функция незаменима. Она может преобразовывать строки в целые числа.
```py

program_name = "Python 3"
version_number = program_name.split()[-1]
int(version_number)

```
Эту функцию также можно использовать для отсечения дробной части у числа с плавающей точкой.
```py

from math import sqrt
sqrt(28)

int(sqrt(28))

```
Обратите внимание, если нужно обрезать дробную часть при делении, оператор «//» более уместен (с отрицательными числами это работает иначе).
```py

int (3/2) == 3 // 2

```
## float
Если строка, которую надо конвертировать в число, не является целым числом, здесь поможет метод float.
```py

program_name = "Python 3"
version_number = program_name.split()[-1]
float(version_number)

pi_digits = '3.141592653589793238462643383279502884197169399375'
len(pi_digits)

float(pi_digits)

```
Float также можно использовать для преобразования целых чисел в числа с плавающей запятой.

В Python 3 целочисленное деление больше не является чем-то особенным (если вы специально не используете оператор «//»). Поэтому больше не нужно использовать float для этой цели, теперь float(x)/y можно легко заменить на x/y.

## list
Эта функция может очень облегчить задачу, если вы хотите составить список из итераций цикла.
```py

numbers = [2, 1, 3, 5, 8]
squares = (n**2 for n in numbers)

list_of_squares = list(squares)

```
При работе со списком метод copy позволяет создать его копию.
```py

copy_of_squares = list_of_squares.copy()

```
Если вы не знаете, с какими элементами работаете, функция list является более общим способом перебора элементов и их копирования.
```py

copy_of_squares = list(list_of_squares)

```
когда вы хотите создать пустой список, следует использовать буквальный синтаксис списка ([ ]).
```py

my_list = list()  # Так делать нельзя
my_list = []      # Так можно

```
Использование [ ] считается более идиоматическим, так как эти скобки на самом деле выглядят как список Python.

## tuple
Эта функция во многом похожа на функцию list, за исключением того, что вместо списков она создает кортежи.
```py

numbers = [2, 1, 3, 4, 7]
tuple(numbers)

```
Если вы пытаетесь создать хешируемую коллекцию (например, ключ словаря), стоит отдать предпочтению кортежу вместо списка.

## dict
Эта функция создаёт новый словарь. Подобно спискам и кортежам, dict эквивалентна проходу по массиву пар «ключ-значение» и созданию из них словаря.
```py

color_counts = [('red', 2), ('green', 1), ('blue', 3), ('purple', 5)]

```
Выведем его на экран с помощью цикла.
```py

colors = {}
for color, n in color_counts:
    colors[color] = n

```
То же самое, но с использованием dict.
```py

colors = dict(color_counts)

```
Функция dict может принимать 2 типа аргументов:
- другой словарь: в этом случае этот словарь будет скопирован;
- список кортежей «ключ-значение»: в этом случае из этих слов будет создан новый словарь.

Поэтому следующий код также будет работать.
```py

new_dictionary = dict(colors)

```
Функция dict также может принимать ключевые слова в качестве аргументов для создания словаря со строковыми ключами.
```py

person = dict(name='Trey Hunner', profession='Python Trainer')

```
Но рекомендуется использовать литералы вместо ключевых слов.
```py

person = {'name': 'Trey Hunner', 'profession': 'Python Trainer'}

```
Такой синтаксис более гибок и немного быстрее. 

Как в случае со списком и кортежем, пустой словарь следует создавать с использованием буквального синтаксиса ({ }).
```py

my_list = dict()  # Так делать нельзя
my_list = {}  # Так можно

```
Использование { } более идиоматично и эффективно с точки зрения использования процессора. Обычно для создания словарей используются фигурные скобки, dict встречается гораздо реже.

## set
Функция set создаёт новый набор. Она принимает итерации из хешируемых значений (строк, чисел или других неизменяемых типов) и возвращает set.
```py

numbers = [1, 1, 2, 3, 5, 8]
set(numbers) # {1, 2, 3, 5, 8}

```
Создать пустой набор с «{ }» нельзя (фигурные скобки создают пустой словарь). Поэтому функция set — лучший способ создать пустой набор.
```py

numbers = set()

```
Можно использовать и другой синтаксис.
```py

{*()}  # Так можно создать пустой набор

# Такой способ имеет недостаток — он сбивает с толку (он основан на редко используемой функции оператора *), поэтому он не рекомендуется.

```

## range
Эта функция создаёт объект range, который представляет собой диапазон чисел.
```py

range(10_000)
range(0, 10000)
range(-1_000_000_000, 1_000_000_000)
range(-1000000000, 1000000000)

```
Результирующий диапазон чисел включает начальный номер, но исключает конечный (range(0, 10) не включает 10).

Данная функция полезна при переборе чисел.
```py

for n in range(0, 50, 10):
    print(n)

```
Обычный вариант использования — выполнить операцию n раз.
```py

first_five = [get_things() for _ in range(5)]

```
Range в Python 3 работает как xrange в Python 2. Числа вычисляются «более лениво» при проходе по диапазону.

## bool
Эта функция проверяет достоверность (истинность) объектов Python. Относительно чисел будет выполняться проверка на неравенство нулю.
```py
bool(5)
bool(-1)
bool(0)
```
Применяя bool к коллекциям, будет проверяться их длина (больше 0 или нет).
```py
bool('hello')
bool('')
bool(['a'])
bool([])
bool({})
bool({1: 1, 2: 4, 3: 9})
bool(range(5))
bool(range(0))
bool(None)

```
Проверка истинности очень важна в Python. Вместо того, чтобы задавать вопросы о длине контейнера, многие новички задают проверку истинности.
```py

# Вместо этого
if len(numbers) == 0:
    print("The numbers list is empty")

# многие делают так
if not numbers:
    print("The numbers list is empty")

```

## enumerate
Если нужно в цикле посчитать количество элементов (по одному элементу за раз), эта функция может быть очень полезной. Такая задача может показаться специфической, но она бывает нужна довольно часто.

Enumerate также часто используется для отслеживания индекса элементов в последовательности.
```py

def palindromic(sequence):
    """Возвращает True, если последовательность является палиндромом."""
    for i, item in enumerate(sequence):
        if item != sequence[-(i+1)]:
            return False
    return True

```
Также следует обратить внимание, что новички в Python часто используют range(len(sequence)). Если вы когда-нибудь встретите конструкции типа range(len(...)), лучше заменить её на enumerate. Она поможет упростить конструкцию операторов.
```py

def palindromic(sequence):
    """Возвращает True, если последовательность является палиндромом."""
    for i in range(len(sequence)):
        if sequence[i] != sequence[-(i+1)]:
            return False
    return True

```
## min и max
Эти функции выдают минимальное и максимальное число из набора соответственно.
```py

numbers = [2, 1, 3, 4, 7, 11, 18]
min(numbers)

max(numbers)

```
Данные методы сравнивают элементы, используя оператор <. Поэтому, все передаваемые в них значения должны быть упорядочены и сопоставимы друг с другом.

Min и max также принимают key-свойство, позволяющее настроить, что на самом деле означают минимум и максимум для конкретных объектов.
```py

fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
min(fruits, key=len)

```

## sorted
Эта функция принимает любой набор элементов и возвращает новый список всех значений в отсортированном порядке.
```py
numbers = [1, 8, 2, 13, 5, 3, 1]
words = ["python", "is", "lovely"]
sorted(words)

sorted(numbers, reverse=True)

```
Данная функция (как min и max) сравнивает элементы, используя оператор <, поэтому все значения, переданные ей, должны быть упорядочены.

Sorted также позволяет настраивать сортировку с помощью key-свойства.

## help
Если вы находитесь в Python Shell или делаете отладку кода с использованием breakpoint, и хотите знать, как работает определённый объект, метод или атрибут, функция help поможет вам.

## input
Эта функция запрашивает у пользователя ввод, ждёт нажатия клавиши Enter, а затем возвращает набранный текст.

Чтение из стандартного ввода — это один из способов получить входные данные в программе. Но есть и много других способов: аргументы командной строки, чтение из файла, чтение из базы данных и многое другое.

## Оператор walrus
Выражения присваивания позволяют вам присваивать и возвращать значение в одном выражении. Например, если вы хотите присвоить переменную и вывести ее значение, вы обычно делаете что-то вроде этого:
```py

    walrus = False
    print(walrus)

```
В Python 3.8 разрешено объединять эти два оператора в один, используя оператор walrus:
```py

    print(walrus := True)

```
Выражение присваивания позволяет присвоить True walrus и сразу же вывести значение. Но оператор walrus не делает ничего такого чего нельзя было бы сделать без него. Он только делает некоторые конструкции более удобными, и иногда может более четко сообщать о намерениях вашего кода.

Один из примеров, демонстрирующий некоторые сильные стороны оператора walrus, – это циклы while, где вам нужно инициализировать и обновить переменную. Например, следующий код запрашивает ввод у пользователя, пока он не наберет quit:
```py

    inputs = list()
    current = input("Write something: ")
    while current != "quit":
        inputs.append(current)
        current = input("Write something: ")

```
Вы повторяете оператор input() два раза, так как вам нужно каким-то образом получить current, прежде чем зайти в цикл. Лучшее решение – установить бесконечный цикл while и использовать break для остановки цикла:
```py
    inputs = list()
    while True:
        current = input("Write something: ")
        if current == "quit":
            break
        inputs.append(current)

```
Этот код эквивалентен приведенному выше, но избегает повторения и сохраняет строки в более логичном порядке. Если вы используете выражение присваивания, вы можете еще больше упростить этот цикл:
```py
    inputs = list()
    while (current := input("Write something: ")) != "quit":
        inputs.append(current)

```

## Определение функции
Функцией называют именованный фрагмент программного кода, к которому можно обратиться из другого места вашей программы. 

## Создание функций
Для создания функции используется ключевое слово def, после которого указывается имя и список аргументов в круглых скобках. Тело функции выделяется также как тело условия (или цикла): четырьмя пробелами
```py

def fun():
    pass
```
## Аргументы в функциях Python

### Функция без аргументов
```py

def my_function():
    print("This is a function without arguments")

my_function()

```
### Функция с явными аргументами

определим функцию, которой передается несколько значений для аргументов. Если вы не укажете значения для всех аргументов функции, то выведется сообщение об ошибке.

Функция, которую мы будем использовать в качестве примера.
```py

def func_args(integer1, integer2):
    result = integer1 + integer2
    return result

result = func_args(10, 20)
print(result)

```
Теперь вызовем метод func_args() без передачи значений для аргументов:
```py

result = func_args()
print(result)

``` 
В результате на экран будет выведена ошибка
Ошибка возникает из-за того, что при вызове функции func_args() отсутствуют два обязательных аргумента integer1 и integer2. Поэтому нужно передать значения для аргументов integer1 и integer2 при вызове функции.

Теперь передадим значение одного из аргументов:
```py

result = func_args(10)
print(result)

```
После выполнения мы снова увидим сообщение об ошибке.
Теперь ошибка возникла из-за того, что значение аргумента integer2 отсутствует. Это означает, что нужно явно передавать значения для всех аргументов функции.

### Функция с аргументами по умолчанию
Это те аргументы, которые принимают значения по умолчанию, если явные значения не переданы им из вызова функции. Определим функцию с одним аргументом по умолчанию.
```py

def find_square(integer1=2):
    result = integer1 * integer1
    return result

```
Если вы вызываете find_square() со значением для аргумента integer1, функция find_square() вернет квадрат этого значения.

Если не передать ни одного значения функции find_square() integer1, то integer1 будет присвоено значение по умолчанию, и функция вернет квадрат 2.
```py

result = find_square(10)
print(result)

```
Теперь вызовем функцию find_square() без какого-либо значения для аргумента argument1. В этом случае функция вернет 4, поскольку при отсутствии значения будет использоваться значение по умолчанию 2.
```py

result = find_square()
print(result)

```
Функция Python также может иметь несколько аргументов по умолчанию. Например, в следующем примере функция складывает целые числа, переданные в качестве аргументов. Если ни одно целое число не передано в функцию, аргументы по умолчанию принимают значения 2 и 4:
```py

def add_ints(integer1=2, integer2=4):
    result = integer1 + integer2
    return result

```
Вызовем функцию add_ints() без каких-либо параметров.
```py

result = add_ints()
print(result)

```
## Возврат значения функцией

функция также может возвращать значение с помощью инструкции return, которая завершит выполнение функции и передаст значения к месту ее вызова. Используя return без аргументов, функция будет возвращать None.

Возврат значения функцией осуществляется с помощью ключевого слова return, после которого указывается возвращаемое значение.
```py

def square(x):
    y = x ** 2
    return y

result = square(3)
print(result)


def add_numbers(x, y, z):
    a = x + y
    b = x + z
    c = y + z
    return a, b, c

sums = add_numbers(1, 2, 3)
print(sums)

```
Функции Python немедленно завершаются, когда встречают инструкцию return, независимо от того, возвращают они значение или нет:
```py

def loop_five():
    for x in range(0, 25):
        print(x)
        if x == 5:
            # Функция останавливается на x == 5
            return
    print("Эта строка не будет выполняться.")

loop_five()

```
Инструкция return в цикле for завершает функцию, поэтому строка вне цикла не будет выполняться. При использовании инструкции break был бы завершен только цикл, и выполнялась последняя строка print().

Инструкция return завершает функцию и может возвращать значение в случае применения параметров.

Функцию можно присвоить переменной и использовать ее, если необходимо сократить имя. В качестве примера можно привести вариант использования функции вычисления факториала из пакета math.
```py
import math

f = math.factorial
print(f(5))
```
## Вычисление числа Фибоначчи.
```py

def fibb(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        return fibb(n-1) + fibb(n-2)
print(fibb(10))

```
## Вычисление факториала.
```py

def factorial(n):
    prod = 1
    for i in range(1, n+1):
        prod *= i
    return prod

print(factorial(5))

```

## Анонимные функции - lambda-функции
Lambda-функция – это безымянная функция с произвольным числом аргументов и вычисляющая одно выражение. Тело такой функции не может содержать более одной инструкции (или выражения). Данную функцию можно использовать в рамках каких-либо конвейерных вычислений (например внутри filter(), map() и reduce()) либо самостоятельно, в тех местах, где требуется произвести какие вычисление, которые удобно “завернуть” в функцию.

Лямбда-функция назначается переменной, и таким образом получается лаконичный способ определения функции:
```py

(lambda x: x**2)(5)

# Lambda-функцию можно присвоить какой-либо переменной и в дальнейшем использовать ее в качестве имени функции.

sqrt = lambda x: x**0.5
sqrt(25)

```

## Локальное и объемлющее пространства имен 
Интерпретатор создает новое пространство имен при каждом выполнении функции. Это пространство является локальным для функции и сохраняется до момента завершения ее действия. 

Функции не существуют независимо друг от друга только на уровне основной программы. Вы также можете определять одну функцию внутри другой.
```py

def f():
    print('Start f()')

    def g():
        print('Start g()')
        print('End g()')
        return
 
    g()

    print('End f()')
    return

f()

```
Когда основная программа вызывает f(), Python создает для нее новое пространство имен. Аналогичным образом, когда f() вызывает g(), последняя получает свое собственное отдельное пространство. Пространство, созданное для g(), является локальным, а пространство, созданное для f(), — объемлющим. 

Все эти пространства существуют до тех пор, пока выполняются соответствующие им функции. По завершении же этих функций Python может не сразу отозвать их из памяти, но при этом все ссылки на содержащиеся в них объекты сразу становятся недоступными.

## Область видимости переменной 
Наличие нескольких отличных пространств имен означает, что в процессе выполнения программы Python несколько разных экземпляров одного имени могут существовать одновременно. Пока каждый из них находится в собственном пространстве, все они обслуживаются по отдельности, и путаницы не происходит. 

Но тут возникает вопрос. Предположим, что вы ссылаетесь на имя x в коде, а оно существует в нескольких пространствах. Как Python узнает, какое именно вы имеете в виду? 

Ответ кроется в понятии области видимости имени, представляющей из себя часть программы, в которой данное имя обладает значением. Интерпретатор определяет эту область в среде выполнения, основываясь на том, где располагается определение имени и из какого места в коде на него ссылаются. 
Отвечая на заданный выше вопрос, отметим, что если ваш код ссылается на имя x, то Python будет искать его следующих областях видимости в таком порядке: 
- Локальная. Если вы ссылаетесь на x внутри функции, то интерпретатор сначала ищет его в самой внутренней области, локальной для этой функции. 
- Объемлющая. Еслиx не находится в локальной области, но появляется в функции, располагающейся внутри другой функции, то интерпретатор ищет его в области видимости объемлющей функции. 
- Глобальная. Если ни один из вышеуказанных вариантов не принес результатов, то интерпретатор продолжит поиск в глобальной области видимости. 
- Встроенная. Если интерпретатор не может найти x где-либо еще, то он направляет поиски во встроенную область видимости. 

Эта последовательность составляет суть правила областей видимости LEGB, как его обычно называют в публикациях о Python. Интерпретатор начинает поиски имени изнутри, последовательно переходя от локальной области видимости к объемлющей, затем к глобальной и в завершении к встроенной.

Если интерпретатор не находит имя ни в одной из этих областей, то Python вызывает исключение NameError.

## Одно определение

В этом примере имя x определено только в одной области. Оно находится за пределами функций f() и g() и поэтому относится к глобальной области видимости. 
```py

x = 'global'

def f():

   def g():
      print(x)
      # Выражение print() может ссылаться только на одно возможное имя x. Оно отображает объект x, определенный в глобальном пространстве имен, которым является строка 'global'.
      g()

f()


```
## Двойное определение

В следующем примере определение x появляется в двух местах: одно —  вне f() и другое —  внутри f(), но за пределами g().
```py

 x = 'global' # определяет x в глобальной области видимости
  
 def f():
      x = 'enclosing' # определяет x снова в объемлющей области видимости
 
      def g():
          print(x)
          # Согласно правилу LEGB интерпретатор находит значение в объемлющей области перед тем, как искать в глобальной. Поэтому выражение print() отображает 'enclosing' вместо 'global'. 
       g()

f()

```

## Тройное определение

Теперь рассмотрим ситуацию, в которой x определен везде и всюду. Одно определение находится вне f(), другое — внутри f(), но за пределами g(), а третье — внутри g().
```py

 x = 'global' # определяет x в глобальной области видимости
  
 def f():
      x = 'enclosing' # определяет x в объемлющей области видимости
 
      def g():
          x = 'local' # определяет x в третий раз в локальной области g()
          print(x)
          # В данном случае правило LEGB утверждает, что g() сначала видит свое собственное значение x, определенное в локальной области видимости. Поэтому выражение print() отображает 'local'.
      g()

f()

```
## Отсутствие определения

g() пытается вывести значение x, но x нигде не определен, поэтому мы получим ошибку.
```py

 def f():

      def g():
          print(x)
          # Python не находит x ни в одном из пространств имен, поэтому выражение print() выдает исключение NameError
       g()
  
f()

```
## Объявление global 
если необходимо изменить значение в глобальной области видимости изнутри f(), Python делает это возможным благодаря использованию объявления global.
```py

x = 20
def f():
     global x
     x = 40
     print(x)

f()

```
Выражение global x указывает на то, что пока выполняется f(), ссылки на имя x будут вести к x, находящемуся в глобальном пространстве имен. Это значит, что присваивание x = 40 не создает новую ссылку. Вместо этого оно присваивает новое значение x в глобальной области видимости. 

Вы также можете указать несколько имен, разделенных запятыми, в одном объявлении global.
```py

x, y, z = 10, 20, 30

def f():
     global x, y, z

```
Здесь x, y и z объявляются для ссылок на объекты в глобальной области видимости посредством одного выражения global.

Имя, определенное в объявлении global, не может появиться в функции раньше выражения global.
```py

def f():
     print(x)
     global x

```
## Объявление nonlocal 
Схожая ситуация наблюдается с определениями вложенных функций. Объявление global позволяет функции обращаться к объекту в глобальной области видимости и менять его. А что если вложенной функции необходимо изменить объект в объемлющей области: 
```py

def f():
     x = 20

     def g():
         x = 40

     g()
     print(x)

f()

```
В этом примере первое определение x дано в объемлющей области, а не в глобальной. Точно так же, как g() не может напрямую изменить переменную в глобальной области, она не способна изменить x в объемлющей области функции. После присваивания x = 40 в строке 5 x в объемлющей области остается 20. 

Поскольку x находится в объемлющей области функции, а не в глобальной, ключевое слово global здесь не сработает. После завершения действия g() значение x в объемлющей области остается 20. 
## Объявление nonlocal 
Для модификации x в объемлющей области изнутри g() вам потребуется аналогичное ключевое слово nonlocal. Имена, определенные после nonlocal, ссылаются на переменные в ближайшей объемлющей области. 
```py

def f():
     x = 20

     def g():
         nonlocal x
         x = 40

     g()
     print(x)

f()

```
После выражения nonlocal x, когда g() ссылается на x, оно обращается к x в ближайшей объемлющей области, чье определение дано внутри f().

## Функция с переменным количеством аргументов

В программировании, если нам нужно выполнять похожие действия, мы определяем функции для многоразового использования кода. Чтобы выполнить это действие, мы вызываем функцию с определённым значением — аргументом.

Предположим, у нас есть функция, которая складывает три числа:
```py

def adder(x, y, z):
    print("sum:",x + y + z)

adder(10, 12, 13)

```
Во фрагменте кода выше у нас есть функция adder() с тремя аргументами: x, y и z. При передаче трёх значений этой функции на выходе мы получаем их сумму. Но что, если передать больше трёх аргументов в эту функцию?
```py

def adder(x, y, z):
    print("sum: ",x + y + z)

adder(5, 10, 15, 20, 25)

```
Из-за того, что здесь мы передаём 5 аргументов, при запуске программы выводится ошибка TypeError: adder() takes 3 positional arguments but 5 were given.

### В Python можно передать переменное количество аргументов двумя способами:
```
*args для неименованных аргументов;
**kwargs для именованных аргументов.

# Мы используем *args и **kwargs в качестве аргумента, когда заранее не известно, сколько значений мы хотим передать функции.

```

## \*args
\*args нужен, когда мы хотим передать неизвестное количество неименованных аргументов. Если поставить * перед именем, это имя будет принимать не один аргумент, а несколько. Аргументы передаются как кортеж и доступны внутри функции под тем же именем, что и имя параметра, только без \*:

```py
def adder(*nums):
    sum = 0
    
    for n in nums:
        sum += n

    print("Sum: ", sum)

adder(3, 5)
adder(4, 5, 6, 7)
adder(1, 2, 3, 5, 6)

# Здесь мы использовали *nums в качестве параметра, который позволяет передавать переменное количество аргументов в функцию adder(). Внутри функции мы проходимся в цикле по этим аргументам, чтобы найти их сумму, и выводим результат.

```

## \*\*kwargs
По аналогии с \*args мы используем \*\*kwargs для передачи переменного количества именованных аргументов. Схоже с \*args, если поставить ** перед именем, это имя будет принимать любое количество именованных аргументов. Кортеж/словарь из нескольких переданных аргументов будет доступен под этим именем:
```py

def intro(**data):
    print("\nData type of argument: ",type(data))

    for key, value in data.items():
        print("{} is {}".format(key, value))

intro(Firstname="Sita", Lastname="Sharma", Age=22, Phone=1234567890)
intro(Firstname="John", Lastname="Wood", Email="johnwood@nomail.com", Country="Wakanda", Age=25, Phone=9876543210)
# В этом случае у нас есть функция intro() с параметром **data. В функцию мы передали два словаря разной длины. Затем внутри функции мы прошлись в цикле по словарям, чтобы вывести их содержимое.

```
### Что нужно запомнить:

```
*args и **kwargs — специальный синтаксис, позволяющий передавать в функцию переменное количество аргументов. При этом, совсем не обязательно использовать имена аргументов args и kwargs;

*args используется для неименованных аргументов, с которыми можно работать как со списком;

**kwargs используется для именованных аргументов, с которыми можно работать как со словарём;
если вы хотите использовать и *args, и **kwargs, то это делается так: func(fargs, *args, **kwargs), порядок следования аргументов важен;

```
## Звёздочки для упаковки аргументов
При определении функции можно использовать * , чтобы собрать переменное количество позиционных аргументов, переданных в функцию. Они помещаются в кортеж:
```py

from random import randint

def roll(*dice):
    return sum(randint(1, die) for die in dice)

# Эта функция принимает любое количество аргументов:
roll(20)
roll(6, 6)
roll(6, 6, 6)

```

```py
   def print_args(farg, *args):
       print("formal arg: %s" % farg)
       for arg in args:
           print("another positional arg: %s" % arg)

   print_args(1, "two", 3)

```
## Использование ** kwargs при написании функций
```py
    # Вы можете определить функцию, которая принимает произвольное количество ключевых слов, используя двойную звезду ** перед именем параметра:

     def print_kwargs(**kwargs):
        print(kwargs)

    # При вызове метода Python создаст словарь всех аргументов и сделает его доступным в теле функции:

    print_kwargs(a="two", b=3)
    
    # параметр ** kwargs в определении функции всегда должен быть последним параметром, и он будет соответствовать только аргументам, переданным после предыдущих.

    def example(a, **kw):
        print kw

    example(a=2, b=3, c=4) # => {'b': 3, 'c': 4}

    # Внутри тела функции, чтобы получить доступ к отдельным элементам в kwargs:

    def print_kwargs(**kwargs):
        for key in kwargs:
            print("key = {0}, value = {1}".format(key, kwargs[key])) 
  
    print_kwargs(a = "two", b = 1)

```
## Использование ** kwargs при вызове функций

Вы можете использовать словарь для присвоения значений параметрам функции:
```py
   def test_func(arg1, arg2, arg3): # Usual function with three arguments
       print("arg1: %s" % arg1)
       print("arg2: %s" % arg2)
       print("arg3: %s" % arg3)

    # Note that dictionaries are unordered, so we can switch arg2 and arg3. Only the names matter.
    kwargs = {"arg3": 3, "arg2": "two"}

    # Bind the first argument (ie. arg1) to 1, and use the kwargs dictionary to bind the others
    test_var_args_call(1, **kwargs)  

```
##  Использование * args при вызове функций

```py

     def print_args(arg1, arg2):
        print(str(arg1) + str(arg2))

    a = [1,2]
    b = tuple([3,4])

    print_args(*a)
    # 12
    print_args(*b)
    # 34

```

## Звёздочки для распаковки
При вызове функции можно использовать оператор * для распаковки итерируемого объекта в аргументы вызова:
```py

fruits = ['lemon', 'pear', 'watermelon', 'tomato']
print(fruits[0], fruits[1], fruits[2], fruits[3])

# Строка print(*fruits) передаёт все элементы списка fruits в вызов print() как отдельные аргументы, поэтому нам даже не нужно знать, сколько элементов в списке.

print(*fruits)

# Здесь оператор * — не просто синтаксический сахар. Без фиксированной длины списка было бы невозможно передать элементы итерируемого объекта как отдельные аргументы, не используя *.

```

Оператор ** делает что-то похожее, только с именованными аргументами. Он позволяет взять словарь с парами ключ-значение и распаковать его в именованные аргументы в вызове функции:
```py
date_info = {'year': "2021", 'month': "07", 'day': "01"}
filename = "{year}-{month}-{day}.txt".format(**date_info)

```
## Порой бывает полезно использовать * несколько раз:
```py

fruits = ['lemon', 'pear', 'watermelon', 'tomato']
numbers = [2, 1, 3, 4, 7]
print(*numbers, *fruits)

# Похожим образом используются **:

date_info = {'year': "2020", 'month': "01", 'day': "01"}
track_info = {'artist': "Beethoven", 'title': 'Symphony No 5'}
filename = "{year}-{month}-{day}-{artist}-{title}.txt".format(
    **date_info,
    **track_info,
)

# Следует соблюдать осторожность при многократном использовании **. В Python функции не могут иметь несколько одинаковых именованных аргументов, поэтому ключи в словарях не должны пересекаться, иначе будет выброшено исключение.

```

```py

# В схожих целях можно применить и **: если использовать этот оператор в объявлении функции, то он соберёт все переданные именованные аргументы в словарь:

def tag(tag_name, **attributes):
    attribute_list = [
        f'{name}="{value}"'
        for name, value in attributes.items()
    ]
    return f"<{tag_name} {' '.join(attribute_list)}>"
# Оператор ** соберёт все переданные именованные аргументы в словарь, на который ссылается аргумент attributes:

tag('a', href="http://example.com")

tag('img', height=20, width=40, src="img.jpg")

```
## Позиционные аргументы с только именованными аргументами
В Python 3 появился специальный синтаксис для только именованных (keyword-only) аргументов. Такие аргументы нельзя указать позиционно, только по имени.
```py

# Чтобы принимать только именованные аргументы, при определении функции мы можем расположить именованные аргументы после *:

def get_multiple(*keys, dictionary, default=None):
    return [
        dictionary.get(key, default)
        for key in keys
    ]
# Эту функцию можно использовать следующим образом:

fruits = {'lemon': 'yellow', 'orange': 'orange', 'tomato': 'red'}
get_multiple('lemon', 'tomato', 'squash', dictionary=fruits, default='unknown')

# Аргументы dictionary и default идут после *keys, а это значит, что их можно указать только как именованные аргументы. Если попытаться сделать иначе, мы получим ошибку:

fruits = {'lemon': 'yellow', 'orange': 'orange', 'tomato': 'red'}
get_multiple('lemon', 'tomato', 'squash', fruits, 'unknown')
# Traceback (most recent call last):
#   File "", line 1, in 
# TypeError: get_multiple() missing 1 required keyword-only argument: 'dictionary'

```
