# @classmethod и @staticmethod

# @staticmethod — используется для создания метода, который ничего не знает о классе или экземпляре, через который он был вызван. Он просто получает переданные аргументы, без неявного первого аргумента, и его определение неизменяемо через наследование.

# @staticmethod — это вроде обычной функции, определенной внутри класса, которая не имеет доступа к экземпляру, поэтому ее можно вызывать без создания экземпляра класса.

# Синтаксис:

# class ClassName:
#     @staticmethod
#     def method_name(arg1, arg2, ...): ...

# Здесь мы используем декоратор @staticmethod для определения статического метода
# статический метод не принимает self в качестве первого аргумента для метода.

class Myclass():
    @staticmethod
    def staticmethod():
        print('static method called')

# мы можем получить доступ к статическому методу класса без создания экземпляра.

Myclass.staticmethod()

# Хотя вызов метода из экземпляра класса тоже возможен.

my_obj = Myclass()
my_obj.staticmethod()

# Статический метод помогает в достижении инкапсуляции в классе, поскольку он не знает о состоянии текущего экземпляра. Кроме того, статические методы делают код более читабельным и повторно используемым, а также более удобным для импорта по сравнению с обычными функциями, поскольку каждую функцию не нужно отдельно импортировать.

class Person():
    @staticmethod
    def is_adult(age):
        if age > 18:
            return True
        else:
            return False
# мы можем проверить, является ли человек взрослым, без инициирование создания экземпляра.

Person.is_adult(23)

# @classmethod — это метод, который получает класс в качестве неявного первого аргумента, точно так же, как обычный метод экземпляра получает экземпляр. Это означает, что вы можете использовать класс и его свойства внутри этого метода, а не конкретного экземпляра.

# @classmethod — это обычный метод класса, имеющий доступ ко всем атрибутам класса, через который он был вызван. Следовательно, classmethod — это метод, который привязан к классу, а не к экземпляру класса.

# Синтаксис:
 
# class Class:
#     @classmethod
#     def method(cls, arg1, arg2, ...): ... 
# декоратор @classmethod используется для создания методов класса, 
# и cls должен быть первым аргументом каждого метода класса.

class MyClass:
    @classmethod
    def classmethod(cls):
        print('Class method called')

# Функцию classmethod также можно вызывать без создания экземпляра класса, но его определение следует за подклассом, а не за родительским классом, через наследование.

MyClass.classmethod()

# @classmethod используется, когда вам нужно получить методы, не относящиеся к какому-либо конкретному экземпляру, но каким-то образом привязанные к классу. Самое интересное в них то, что их можно переопределить дочерними классами.

# Поэтому, если вы хотите получить доступ к свойству класса в целом, а не к свойству конкретного экземпляра этого класса, используйте classmethod.

class ParentClass():
    
    TOTAL_OBJECTS=0
    
    def __init__(self):
        ParentClass.TOTAL_OBJECTS = ParentClass.TOTAL_OBJECTS+1
       
    @classmethod
    def total_objects(cls):
        print("Total objects: ",cls.TOTAL_OBJECTS)

# Создаем объекты        

my_obj1 = ParentClass()
my_obj2 = ParentClass()
my_obj3 = ParentClass()

# Вызываем classmethod 
ParentClass.total_objects()

# Теперь, если мы унаследуем этот класс в дочерний класс и объявим там переменную TOTAL_OBJECTS и вызовем метод класса из дочернего класса, он вернет общее количество объектов для дочернего класса.

# Создаем дочерний класс
class ChildClass(ParentClass):
    
    TOTAL_OBJECTS=0 

    def __init__(self):
        super().__init__()
        ChildClass.TOTAL_OBJECTS = ChildClass.TOTAL_OBJECTS+1

chil_obj = ChildClass()

ParentClass.total_objects()

ChildClass.total_objects()

# @classmethod используется в суперклассе для определения того, как метод должен вести себя, когда он вызывается разными дочерними классами. В то время как @staticmethod используется, когда мы хотим вернуть одно и то же, независимо от вызываемого дочернего класса.

# вызов @classmethod включает в себя дополнительное выделение памяти, чего нет при вызове @staticmethod или обычной функции.
